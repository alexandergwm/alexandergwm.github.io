<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>知识总结：用python做信号处理 | Gavin</title><meta name="author" content="Gavin"><meta name="copyright" content="Gavin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="用Python做信号处理 声明：本文中设计的知识和代码大部分来自：芥末的无奈的博客_CSDN博客-音频处理,c++,keras领域博主  以及  凌逆战 - 博客园 (cnblogs.com) 两位大神所写，我自己总结并自己手打一遍代码进行学习，用作自己之后的回顾和复习，绝不参与任何商业活动，如有侵权，请联系我进行删除，非常感谢。  [TOC] 1、Python 生成正弦信号假设我们想用pytho">
<meta property="og:type" content="article">
<meta property="og:title" content="知识总结：用python做信号处理">
<meta property="og:url" content="http://example.com/2023/08/25/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="Gavin">
<meta property="og:description" content="用Python做信号处理 声明：本文中设计的知识和代码大部分来自：芥末的无奈的博客_CSDN博客-音频处理,c++,keras领域博主  以及  凌逆战 - 博客园 (cnblogs.com) 两位大神所写，我自己总结并自己手打一遍代码进行学习，用作自己之后的回顾和复习，绝不参与任何商业活动，如有侵权，请联系我进行删除，非常感谢。  [TOC] 1、Python 生成正弦信号假设我们想用pytho">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.ibb.co/Tw3pLRH/68747470733a2f2f692e68697a6c69726573696d2e636f6d2f564d7935596a2e706e67.png">
<meta property="article:published_time" content="2023-08-25T06:58:38.000Z">
<meta property="article:modified_time" content="2024-05-05T12:11:25.738Z">
<meta property="article:author" content="Gavin">
<meta property="article:tag" content="开源代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.ibb.co/Tw3pLRH/68747470733a2f2f692e68697a6c69726573696d2e636f6d2f564d7935596a2e706e67.png"><link rel="shortcut icon" href="https://i.ibb.co/3BGBwps/2c8b98a62fbc3615.png"><link rel="canonical" href="http://example.com/2023/08/25/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '知识总结：用python做信号处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-05 20:11:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.ibb.co/ch2RrDp/20230822001522.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.ibb.co/Tw3pLRH/68747470733a2f2f692e68697a6c69726573696d2e636f6d2f564d7935596a2e706e67.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Gavin"><img class="site-icon" src="https://i.ibb.co/3BGBwps/2c8b98a62fbc3615.png"/><span class="site-name">Gavin</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">知识总结：用python做信号处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-25T06:58:38.000Z" title="发表于 2023-08-25 14:58:38">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-05T12:11:25.738Z" title="更新于 2024-05-05 20:11:25">2024-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">知识总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="知识总结：用python做信号处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="用Python做信号处理"><a href="#用Python做信号处理" class="headerlink" title="用Python做信号处理"></a>用Python做信号处理</h1><hr>
<p>声明：本文中设计的知识和代码大部分来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weiwei9363">芥末的无奈的博客_CSDN博客-音频处理,c++,keras领域博主</a>  以及  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LXP-Never/">凌逆战 - 博客园 (cnblogs.com)</a> 两位大神所写，我自己总结并自己手打一遍代码进行学习，用作自己之后的回顾和复习，绝不参与任何商业活动，如有侵权，请联系我进行删除，非常感谢。</p>
<hr>
<p>[TOC]</p>
<h2 id="1、Python-生成正弦信号"><a href="#1、Python-生成正弦信号" class="headerlink" title="1、Python 生成正弦信号"></a>1、Python 生成正弦信号</h2><p>假设我们想用python生成一个正弦信号$x[n] &#x3D; Acos(2\pi fnT+\Phi)$ ，其中$A$为幅度，$f$为信号频率，$n$为时间下标，$T&#x3D;1&#x2F;f_s$为采样间隔,$f_s$ 为采样频率，$\Phi$ 为相位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 这个程序用来生成正弦信号</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_sinusoid</span>(<span class="params">N,A,f0,fs,phi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param N(int): number of samples</span></span><br><span class="line"><span class="string">    :param A(float): amplitude</span></span><br><span class="line"><span class="string">    :param f0(float): frequency</span></span><br><span class="line"><span class="string">    :param fs(float): sample rate</span></span><br><span class="line"><span class="string">    :param phi(float): initial phase</span></span><br><span class="line"><span class="string">    :return: x(numpy array): sinusoid signal which length is M</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    T = <span class="number">1</span>/fs</span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    x = A * np.cos(<span class="number">2</span>*f0*np.pi*n*T+phi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_sinusoid_2</span>(<span class="params">t,A,f0,fs,phi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param t(float): the time of generated signal</span></span><br><span class="line"><span class="string">    :param A(float): amplitude</span></span><br><span class="line"><span class="string">    :param f0(float): frequency</span></span><br><span class="line"><span class="string">    :param fs(float): sample rate</span></span><br><span class="line"><span class="string">    :param phi(float): initial phase</span></span><br><span class="line"><span class="string">    :return: x(numpy array): sinusoid signal which length is M</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    T = <span class="number">1.0</span>/fs</span><br><span class="line">    N = t/T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    N = <span class="number">511</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    t = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    n = np.arange(<span class="number">0</span>,<span class="number">0.02</span>,<span class="number">1</span>/fs)</span><br><span class="line"></span><br><span class="line">    phi = <span class="number">0</span></span><br><span class="line">    x = generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line">    x2 = generate_sinusoid_2(t,A,f0,fs,phi)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(n,x2)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223180138570-1692660741460-2.png" alt="image-20230223180138570" style="zoom: 33%;" />





<h2 id="2、Python读取与保存音频信号"><a href="#2、Python读取与保存音频信号" class="headerlink" title="2、Python读取与保存音频信号"></a>2、Python读取与保存音频信号</h2><p>Python有很多种方法和库读取音频信号，其中推荐和常用的主要是scipy库和librosa库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This scipt is used scipy library to read the sound file data</span></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"></span><br><span class="line">fs,sig = wavfile.read(<span class="string">&#x27;data/speech@24kHz.wav&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sampling rate = &quot;</span>)   <span class="comment"># 24000</span></span><br><span class="line"><span class="built_in">print</span>(fs)</span><br><span class="line">f1 = plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(sig)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Read data by scipy package&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signal,sample_rate = librosa.load(<span class="string">&#x27;data/speech@24kHz.wav&#x27;</span>,sr = <span class="number">44100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sampling_rate = &quot;</span> )  <span class="comment"># 44100, In librosa package, we can input the sampling rate by ourselves</span></span><br><span class="line"><span class="built_in">print</span>(sample_rate)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(signal)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Read data by librosa package&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># store</span></span><br><span class="line">path = <span class="string">&#x27;output.wav&#x27;</span></span><br><span class="line">librosa.output.write_wav(path,data.astype(np.float32),sr = sample_rate)</span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230224134033147.png" alt="image-20230224134033147" style="zoom: 33%;" />





<h2 id="3、离散傅里叶变换-DFT"><a href="#3、离散傅里叶变换-DFT" class="headerlink" title="3、离散傅里叶变换(DFT)"></a>3、离散傅里叶变换(DFT)</h2><p>离散傅里叶变换，可以将采样及量化后的离散信号变换到频域：</p>
<p><img src="D:\Majority\算法\typora\image-20230223184403060.png" alt="image-20230223184403060"></p>
<p>在这里，我不详细阐述DFT的理论及背后的物理意义，我更关心怎么用python实现DFT</p>
<h3 id="1、Scipy-包的FFT"><a href="#1、Scipy-包的FFT" class="headerlink" title="1、Scipy 包的FFT"></a>1、Scipy 包的FFT</h3><p>这里我们可以使用Scipy库中的FFT算法计算DFT（这里需要输入信号长度为$2^n$ 才可以使用FFT，若不为$2^n$,那么默认为DFT）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 这个程序用来生成正弦信号</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_sinusoid</span>(<span class="params">N,A,f0,fs,phi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param N(int): number of samples</span></span><br><span class="line"><span class="string">    :param A(float): amplitude</span></span><br><span class="line"><span class="string">    :param f0(float): frequency</span></span><br><span class="line"><span class="string">    :param fs(float): sample rate</span></span><br><span class="line"><span class="string">    :param phi(float): initial phase</span></span><br><span class="line"><span class="string">    :return: x(numpy array): sinusoid signal which length is M</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    T = <span class="number">1</span>/fs</span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    x = A * np.cos(<span class="number">2</span>*f0*np.pi*n*T+phi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_sinusoid_2</span>(<span class="params">t,A,f0,fs,phi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param t(float): the time of generated signal</span></span><br><span class="line"><span class="string">    :param A(float): amplitude</span></span><br><span class="line"><span class="string">    :param f0(float): frequency</span></span><br><span class="line"><span class="string">    :param fs(float): sample rate</span></span><br><span class="line"><span class="string">    :param phi(float): initial phase</span></span><br><span class="line"><span class="string">    :return: x(numpy array): sinusoid signal which length is M</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    T = <span class="number">1.0</span>/fs</span><br><span class="line">    N = t/T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    N = <span class="number">511</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    t = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    n = np.arange(<span class="number">0</span>, <span class="number">0.02</span>, <span class="number">1</span> / fs)</span><br><span class="line"></span><br><span class="line">    phi = <span class="number">0</span></span><br><span class="line">    x = generate_sinusoid(N, A, f0, fs, phi)</span><br><span class="line">    x2 = generate_sinusoid_2(t, A, f0, fs, phi)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(n, x2)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test02</span>():</span><br><span class="line">    <span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line">    N = <span class="number">511</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    phi = <span class="number">1.0</span></span><br><span class="line">    x = generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line">    <span class="comment"># do fft</span></span><br><span class="line">    X = fft(x)</span><br><span class="line">    mX = np.<span class="built_in">abs</span>(X)  <span class="comment"># magnitude</span></span><br><span class="line">    pX = np.angle(X)  <span class="comment"># phase</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot the magnitude and phase</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    plt.plot(mX)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    plt.plot(pX)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test02()</span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223185042666.png" alt="image-20230223185042666" style="zoom: 50%;" />

<h3 id="2、通过矩阵运算求DFT"><a href="#2、通过矩阵运算求DFT" class="headerlink" title="2、通过矩阵运算求DFT"></a>2、通过矩阵运算求DFT</h3><p>通过DFT的定义式，我们可以考虑将其用矩阵相乘的方式写出来，也就是会变为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223185335162.png" alt="image-20230223185335162" style="zoom:50%;" />

<p>其中$S_k &#x3D; e^{-j2\pi kn&#x2F;N}$ ，那么我们可以考虑构建出S矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_complex_sinusoid_matrix</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param N(int): length of complex sinusoid in samples</span></span><br><span class="line"><span class="string">    :return: S_k(numpy_array): matrix</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    n = np.expand_dims(n,axis = <span class="number">1</span>)  <span class="comment"># 扩展维度，将一维矩阵转换为二维矩阵，方便后面的矩阵相乘</span></span><br><span class="line">    k = n</span><br><span class="line">    m = n.T * k / N</span><br><span class="line">    S = np.exp(<span class="number">1j</span>*<span class="number">2</span>*np.pi*m)</span><br><span class="line">    <span class="keyword">return</span> np.conjugate(S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test03</span>():</span><br><span class="line">    N = <span class="number">511</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    phi = <span class="number">1.0</span></span><br><span class="line">    x = generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line">    <span class="comment"># do fft</span></span><br><span class="line">    S = generate_complex_sinusoid_matrix(N)</span><br><span class="line">    X_2 = np.dot(S,x)</span><br><span class="line">    mX = np.<span class="built_in">abs</span>(X_2)</span><br><span class="line">    pX = np.angle(X_2)</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    plt.plot(mX)</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    plt.plot(pX)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223185042666-1692690706922-3.png" alt="image-20230223185042666" style="zoom: 33%;" />

<h3 id="3、傅里叶变换的基本性质"><a href="#3、傅里叶变换的基本性质" class="headerlink" title="3、傅里叶变换的基本性质"></a>3、傅里叶变换的基本性质</h3><p><strong>傅里叶变换主要有：1、线性性质  2、平移性质   3、对称性质   4、卷积性质 四种性质。</strong></p>
<h4 id="一、线性性质"><a href="#一、线性性质" class="headerlink" title="一、线性性质"></a>一、线性性质</h4><p>两个函数之和的傅里叶变换等于各自变换之和</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223191147298.png" alt="image-20230223191147298" style="zoom: 50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个程序用来证明傅里叶变换的四种性质</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_complex_signal</span>(<span class="params">num_sample,k0</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param num_sample: N</span></span><br><span class="line"><span class="string">    :param k0:  the frequency</span></span><br><span class="line"><span class="string">    :return: sin wave</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    n = np.arange(num_sample)</span><br><span class="line">    x = np.exp(<span class="number">1j</span>*<span class="number">2</span>*np.pi*k0*n/num_sample)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Linearity</span>():</span><br><span class="line">    num_sample = <span class="number">100</span></span><br><span class="line">    k0 = <span class="number">20</span></span><br><span class="line">    x1 = generate_complex_signal(num_sample, k0)</span><br><span class="line"></span><br><span class="line">    num_sample = <span class="number">100</span></span><br><span class="line">    k0 = <span class="number">10</span></span><br><span class="line">    x2 = generate_complex_signal(num_sample, k0)</span><br><span class="line"></span><br><span class="line">    X1 = fft(x1)</span><br><span class="line">    X2 = fft(x2)</span><br><span class="line">    mX1 = np.<span class="built_in">abs</span>(X1)</span><br><span class="line">    mX2 = np.<span class="built_in">abs</span>(X2)</span><br><span class="line"></span><br><span class="line">    x12 = x1 + x2</span><br><span class="line">    X12 = fft(x12)</span><br><span class="line">    mX12 = np.<span class="built_in">abs</span>(X12)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">321</span>)</span><br><span class="line">    plt.plot(x1)</span><br><span class="line">    plt.subplot(<span class="number">322</span>)</span><br><span class="line">    plt.plot(x2)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">323</span>)</span><br><span class="line">    plt.plot(mX1)</span><br><span class="line">    plt.subplot(<span class="number">324</span>)</span><br><span class="line">    plt.plot(mX2)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">325</span>)</span><br><span class="line">    plt.plot(mX1 + mX2)</span><br><span class="line">    plt.subplot(<span class="number">326</span>)</span><br><span class="line">    plt.plot(mX12)</span><br><span class="line"></span><br><span class="line">    plt.show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    Linearity()</span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223210232799.png" alt="image-20230223210232799" style="zoom:50%;" />

<h4 id="二、平移性质"><a href="#二、平移性质" class="headerlink" title="二、平移性质"></a>二、平移性质</h4><p>在时域上对信号进行平移，等价于在频域的复平面上旋转一个角度，相反的，频域的复平面上旋转一个角度，等价于时域上的平移，并且平移只对DFT的相位有影响，但是不会改变DFT的幅度。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223210418058.png" alt="image-20230223210418058" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shift</span>():</span><br><span class="line">    x1 = np.linspace(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">50</span>)</span><br><span class="line">    x1 = np.append(x1, <span class="number">0</span>)</span><br><span class="line">    x1 = np.append(x1, np.linspace(-<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">    shifted_x = np.roll(x1, <span class="number">10</span>)  <span class="comment"># shift signal</span></span><br><span class="line"></span><br><span class="line">    X1 = fft(x1)</span><br><span class="line">    shiftedX = fft(shifted_x)</span><br><span class="line"></span><br><span class="line">    mX1 = np.<span class="built_in">abs</span>(X1)</span><br><span class="line">    pX1 = np.angle(X1)</span><br><span class="line">    pX1 = np.unwrap(pX1)</span><br><span class="line"></span><br><span class="line">    mshiftedX = np.<span class="built_in">abs</span>(shiftedX)</span><br><span class="line">    pshiftedX = np.angle(shiftedX)</span><br><span class="line">    pshiftedX = np.unwrap(pshiftedX)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot the results</span></span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">321</span>)</span><br><span class="line">    plt.plot(x1)</span><br><span class="line">    plt.subplot(<span class="number">322</span>)</span><br><span class="line">    plt.plot(shifted_x)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">323</span>)</span><br><span class="line">    plt.plot(mX1)</span><br><span class="line">    plt.subplot(<span class="number">324</span>)</span><br><span class="line">    plt.plot(mshiftedX)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">325</span>)</span><br><span class="line">    plt.plot(pX1)</span><br><span class="line">    plt.subplot(<span class="number">326</span>)</span><br><span class="line">    plt.plot(pshiftedX)</span><br><span class="line"></span><br><span class="line">    plt.show();</span><br></pre></td></tr></table></figure>

<h3 id="三、对称性质"><a href="#三、对称性质" class="headerlink" title="三、对称性质"></a>三、对称性质</h3><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223210813204.png" alt="image-20230223210813204" style="zoom: 80%;" />

<h3 id="四、卷积性质"><a href="#四、卷积性质" class="headerlink" title="四、卷积性质"></a>四、卷积性质</h3><p>时域上的卷积等于频域上的乘积</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223210851167.png" alt="image-20230223210851167" style="zoom: 67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convolution</span>():</span><br><span class="line">    <span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line">    x1 = get_window(<span class="string">&#x27;hanning&#x27;</span>,<span class="number">256</span>)</span><br><span class="line">    x2 = np.cos(np.linspace(<span class="number">0</span>,<span class="number">2</span>*np.pi,<span class="number">256</span>))</span><br><span class="line">    conv_x = np.convolve(x1,x2,<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    X1 = fft(x1)</span><br><span class="line">    X2 = fft(x2)</span><br><span class="line">    CX = fft(conv_x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">321</span>)</span><br><span class="line">    plt.plot(x1)</span><br><span class="line">    plt.subplot(<span class="number">322</span>)</span><br><span class="line">    plt.plot(x2)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">323</span>)</span><br><span class="line">    plt.plot(np.<span class="built_in">abs</span>(X1))</span><br><span class="line">    plt.subplot(<span class="number">324</span>)</span><br><span class="line">    plt.plot(np.<span class="built_in">abs</span>(X2))</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">325</span>)</span><br><span class="line">    plt.plot(np.<span class="built_in">abs</span>(CX))</span><br><span class="line">    plt.subplot(<span class="number">326</span>)</span><br><span class="line">    plt.plot(np.<span class="built_in">abs</span>(X1 * X2))</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223211143907.png" alt="image-20230223211143907" style="zoom: 50%;" />

<h2 id="4、卷积-（Convolution）"><a href="#4、卷积-（Convolution）" class="headerlink" title="4、卷积 （Convolution）"></a>4、卷积 （Convolution）</h2><p>在之前的DFT的介绍当中，我们提及到了卷积性质，先来复习一下卷积的定义如下：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230223211406709.png" alt="image-20230223211406709" style="zoom: 67%;" />

<p>也就是说我们输入信号$x[n]$ 经过一个冲激响应为$h[n]$ 的LTI系统后，得到的输出为$y[n]$，这个过程就是卷积，那么我们如何获取系统的$h[n]$呢，我们只需要对这个系统输入一个理想的单位冲激信号$\delta(t)$ 就可以了，但是在现实世界中，不存在理想的$\delta(t)$，所以我们考虑用另外的方法，关于房间脉冲响应的测量的原理请看这：**<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/430228694">Impulse Response Measurement 脉冲响应测量 - 知乎 (zhihu.com)</a>**</p>
<p>那么同样的我们想要对输入声源加入一个混响也就可以通过卷积实现，我们可以将一个封闭房间的脉冲响应与我们的输入信号相卷积，得到的输出就是加入了这个房间声学性能后的混响音频。假设录制得到的房间脉冲响应为$h(n)$，长度为$n$,输入信号$x(n)$，长度为$m$.</p>
<p>但是从卷积定义开始，有个问题在于其计算复杂度比较高，首先要对脉冲响应信号翻折然后平移，之后要对每个采样点进行N次乘法以及N次加法，所以总共有乘法$N<em>M$ 次以及加法$N</em>M$次，那么算法复杂度就是$O(N*M)$。</p>
<p>所以为了提高计算性能，研究人员提出了一些快速卷积的方法（如FFT，overlap-save,overlap-add）等，在之后会逐步介绍。</p>
<h3 id="FFT卷积（快速傅里叶变换）"><a href="#FFT卷积（快速傅里叶变换）" class="headerlink" title="FFT卷积（快速傅里叶变换）"></a>FFT卷积（快速傅里叶变换）</h3><p>在之前我们提到过的卷积定理，在时域上做卷积就是在频域上做乘积，所以利用这个定理，我们就可以将$h(n)$ 和$x(n)$通过快速傅里叶变换(FFT)得到其在频域表达式$H(w)$和$X(w)$，最后让他们两相乘，得到$Y(w)$，最后将$Y(w)$通过IFFT从频域变回时域即可。关于$FFT$的原理，我们一般关心Radix-2算法，也就是要求输入信号长度必须是$2^n$ ，并根据指数项的周期性可以得到FFT的蝶式单元，详情可以看这篇文章：[<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110897470">精品讲义]—快速傅里叶变换(Fast Fourier Transformation) - 知乎 (zhihu.com)</a> 以及英文版的推导：<a target="_blank" rel="noopener" href="https://users.aalto.fi/~laines10/FFT.html">FFT ~ 快速傅里叶变换 (aalto.fi)</a>，这种采用分而治之思想处理的算法会让计算复杂度在$O(nlog(n))$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This script is used to implement the radix-2 FFT algorithm</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">naiveFFT</span>(<span class="params">x</span>):</span><br><span class="line">    N = x.size</span><br><span class="line">    X = np.ones(N)*(<span class="number">0</span>+<span class="number">0j</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        A = np.ones(N)*(<span class="number">0</span>+<span class="number">0j</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            A[n] = x[n] * np.exp(-np.<span class="built_in">complex</span>(<span class="number">0</span>,<span class="number">2</span>*np.pi*k*n/N))</span><br><span class="line">        X[k] = <span class="built_in">sum</span>(A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FFT</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param x: The input signal in time domain</span></span><br><span class="line"><span class="string">    :return: X: The output signal in frequency domain</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x = np.array(x,dtype=<span class="built_in">float</span>)</span><br><span class="line">    N = <span class="built_in">int</span>(x.size)</span><br><span class="line">    <span class="comment"># Use the naive version when the size is small enough</span></span><br><span class="line">    <span class="keyword">if</span> N &lt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span>  naiveFFT(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Calculate the first half of the W vector</span></span><br><span class="line">        k = np.arange(N/<span class="number">2</span>)</span><br><span class="line">        W = np.exp(-<span class="number">2j</span>*np.pi*k/N)</span><br><span class="line">        evens = FFT(x[::<span class="number">2</span>])</span><br><span class="line">        odds = FFT(x[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> np.concatenate([evens + (W * odds), evens- (W*odds)])  <span class="comment"># concate the two sides</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_sinusoid</span>(<span class="params">N,A,f0,fs,phi</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param N(int): number of samples</span></span><br><span class="line"><span class="string">    :param A(float): amplitude</span></span><br><span class="line"><span class="string">    :param f0(float): frequency</span></span><br><span class="line"><span class="string">    :param fs(float): sample rate</span></span><br><span class="line"><span class="string">    :param phi(float): initial phase</span></span><br><span class="line"><span class="string">    :return: x(numpy array): sinusoid signal which length is M</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    T = <span class="number">1</span>/fs</span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    x = A * np.cos(<span class="number">2</span>*f0*np.pi*n*T+phi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    N = <span class="number">2</span> ** <span class="number">10</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    phi = <span class="number">0</span></span><br><span class="line">    t = np.linspace(<span class="number">0</span>,<span class="number">10</span>,N)</span><br><span class="line">    T = t[<span class="number">1</span>] - t[<span class="number">0</span>]</span><br><span class="line">    signal = generate_sinusoid(N,A,f0,fs,phi)</span><br><span class="line">    fft = FFT(signal)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the frequency scale for the plot</span></span><br><span class="line">    freq_scale = np.linspace(<span class="number">0</span>,<span class="number">1</span>/T,N)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sampling_frequency:&quot;</span> + <span class="built_in">str</span>(<span class="number">1</span>/T))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot the results</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.subplot(<span class="number">311</span>)</span><br><span class="line">    plt.plot(t,signal)</span><br><span class="line">    plt.title(<span class="string">&quot;time domain&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">312</span>)</span><br><span class="line">    plt.plot(freq_scale,np.absolute(fft))</span><br><span class="line">    plt.title(<span class="string">&#x27;Frequency domain by own&#x27;</span>)</span><br><span class="line">    plt.subplot(<span class="number">313</span>)</span><br><span class="line">    plt.plot(freq_scale,np.absolute(np.fft.fft(signal)))</span><br><span class="line">    plt.title(<span class="string">&quot;Frequency domain by scipy&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test01()</span><br></pre></td></tr></table></figure>

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230224125500480.png" alt="image-20230224125500480" style="zoom: 33%;" />

<p>而我们在这个从时域转换到频域再相乘的过程中，会有一些问题，一个是$h(n)$ 和$x(n)$ 的长度通常不相同，但是在频域相乘过程中，我们需要$H(w)$ 和$X(w)$ 的长度是相同的，所以我们通过在信号尾部进行$zero-padding$ 操作，将$h(n)$ 和$x(n)$ 填充到相同长度$k$,$(k\geq M+N-1)$。我们在这里用一些案例来演示。</p>
<p>总而言之，运用FFT算法对两个长度不同信号进行卷积的步骤如下：</p>
<ul>
<li>计算K的大小，确保$K\geq M+N-1$，然后最好能够保证其为2的次方长度，这样能够满足FFT的使用条件</li>
<li>利用zero-padding将$x(n)$ 和$h(n)$ 均填充到k的长度，然后利用卷积定理，将其两分别变换到频域再相乘$Y&#x3D;X*H$</li>
<li>最后将输出信号利用IFFT变换回时域，就可以得到最终的卷积效果，也就是最终的输入信号经过LTI系统后的结果。</li>
</ul>
<h4 id="在干净语音信号中增加混响-（傅里叶变换的应用）"><a href="#在干净语音信号中增加混响-（傅里叶变换的应用）" class="headerlink" title="在干净语音信号中增加混响 （傅里叶变换的应用）"></a>在干净语音信号中增加混响 （傅里叶变换的应用）</h4><p>这里我们采用一个采样频率为24kHz的语音信号”Please Call Stella”作为输入信号$x(n)$， 并采用一个采样频率为16kHz的Lecture房间的RIR，并用Librosa读取时候用24kHz采样率读取。其在时域的波形如下：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230224140329164.png" alt="image-20230224140329164" style="zoom:33%;" />

<p>可以很明显的看到$x(n)$ 和$h(n)$ 的长度不相同，其中$x(n)$ 长度为49237,而$h(n)$ 长度为32768，所以我们考虑将他们zero-padding至相同的长度，长度最好为$K \geq N+M-1$ 且为2的倍数（方便之前所提及的Radix-2 FFT算法。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230224143710766.png" alt="image-20230224143710766" style="zoom:33%;" />

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to convolve the different input signal and impulse response</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad_zeros_to</span>(<span class="params">x,new_length</span>):</span><br><span class="line">    output = np.zeros((new_length,))</span><br><span class="line">    output[:x.shape[<span class="number">0</span>]] = x</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_power_of_2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (<span class="built_in">int</span>(np.log2(n-<span class="number">1</span>))+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fft_convolution</span>(<span class="params">x,h,K=<span class="literal">None</span></span>):</span><br><span class="line">    Nx = x.shape[<span class="number">0</span>]</span><br><span class="line">    Nh = h.shape[<span class="number">0</span>]</span><br><span class="line">    Ny = Nx + Nh - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> K <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        K = next_power_of_2(Ny)</span><br><span class="line">    X = np.fft.fft(pad_zeros_to(x,K))</span><br><span class="line">    H = np.fft.fft(pad_zeros_to(h,K))</span><br><span class="line">    Y = X*H</span><br><span class="line">    y = np.real(np.fft.ifft(Y))</span><br><span class="line">    <span class="keyword">return</span> y[:Ny]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_read</span>():</span><br><span class="line">    <span class="comment"># Read the input clear signal</span></span><br><span class="line">    fs, signal = wavfile.read(<span class="string">&#x27;data/speech@24kHz.wav&#x27;</span>)</span><br><span class="line">    <span class="comment"># Read the RIR</span></span><br><span class="line">    ir, fir = librosa.load(<span class="string">&#x27;data/air_type1_air_binaural_lecture_0_1.wav&#x27;</span>,sr = <span class="number">24000</span>)</span><br><span class="line">    <span class="comment">#plt.figure()</span></span><br><span class="line">    <span class="comment">#plt.subplot(211)</span></span><br><span class="line">    <span class="comment">#plt.plot(signal)</span></span><br><span class="line">    <span class="comment">#plt.ylabel(&quot;Amplitude&quot;)</span></span><br><span class="line">    <span class="comment">#plt.title(&quot;Input signal&quot;)</span></span><br><span class="line">    <span class="comment">#plt.grid()</span></span><br><span class="line">    <span class="comment">#plt.subplot(212)</span></span><br><span class="line">    <span class="comment">#plt.plot(ir)</span></span><br><span class="line">    <span class="comment">#plt.xlabel(&#x27;Time/s&#x27;)</span></span><br><span class="line">    <span class="comment">#plt.ylabel(&quot;Amplitude&quot;)</span></span><br><span class="line">    <span class="comment">#plt.title(&quot;Room Impulse Response&quot;)</span></span><br><span class="line">    <span class="comment">#plt.grid()</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line">    <span class="keyword">return</span> signal, ir</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    signal,ir = data_read()</span><br><span class="line">    output = fft_convolution(signal,ir)</span><br><span class="line">    sample_rate = <span class="number">24000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(output))</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(output)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Time/s&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Output signal&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    path = <span class="string">&#x27;output.wav&#x27;</span></span><br><span class="line">    wavfile.write(path,<span class="number">24000</span>,output.astype(np.float32))</span><br></pre></td></tr></table></figure>

<h4 id="用FFT将信号转换到频域去除能量较低的底噪-（傅里叶变换的应用）"><a href="#用FFT将信号转换到频域去除能量较低的底噪-（傅里叶变换的应用）" class="headerlink" title="用FFT将信号转换到频域去除能量较低的底噪 （傅里叶变换的应用）"></a>用FFT将信号转换到频域去除能量较低的底噪 （傅里叶变换的应用）</h4><p>假设此时我们有一个频率的干净信号与一些能量较低的底噪信号相混合的混合信号，我们想要去除掉底噪，得到干净的信号，就可以使用FFT将信号从时域变换到频域进行表示，并在频域寻找其能量最大的值作为我们的干净信号，去除掉那些不等于能量最大的频率，然后再变换回时域，就可以得到干净信号了。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230224152227859.png" alt="image-20230224152227859" style="zoom: 50%;" />

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to transfer the signal from time domain to</span></span><br><span class="line"><span class="comment"># freqeuncy domain to denoise some noise with low energy</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> wavfile</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"></span><br><span class="line"><span class="comment">## Read the audio data</span></span><br><span class="line">noised_sig,sample_rate = librosa.load(<span class="string">&#x27;data/Signal_with_low_energy_noise.wav&#x27;</span>,sr = <span class="number">44100</span>)</span><br><span class="line">times = np.arange(noised_sig.size)/sample_rate;   <span class="comment"># Use the length of signal over sample rate to get the total time</span></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">&#x27;Filter&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Time domain&#x27;</span>,fontsize = <span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Signal&quot;</span>,fontsize =  <span class="number">12</span>)</span><br><span class="line">plt.tick_params(labelsize = <span class="number">10</span>)</span><br><span class="line">plt.grid(linestyle= <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.plot(times[:<span class="number">178</span>],noised_sig[:<span class="number">178</span>],c=<span class="string">&#x27;orangered&#x27;</span>,label=<span class="string">&#x27;Noised&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment">## Do the FFT</span></span><br><span class="line">freqs = np.fft.fftfreq(times.size,times[<span class="number">1</span>]-times[<span class="number">0</span>])</span><br><span class="line">complex_array = np.fft.fft(noised_sig)</span><br><span class="line">pows = np.<span class="built_in">abs</span>(complex_array)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Frequency Domain&#x27;</span>,fontsize = <span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Power&#x27;</span>,fontsize = <span class="number">12</span>)</span><br><span class="line">plt.tick_params(labelsize = <span class="number">10</span>)</span><br><span class="line">plt.grid(linestyle = <span class="string">&quot;:&quot;</span>)</span><br><span class="line">plt.semilogy(freqs[freqs&gt;<span class="number">0</span>],pows[freqs&gt;<span class="number">0</span>],c=<span class="string">&#x27;limegreen&#x27;</span>,label=<span class="string">&#x27;Noised&#x27;</span>)  <span class="comment"># we just want the frequency and power that frequency greater than 0</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment">## remove the noise with low power and plot in frequency domain</span></span><br><span class="line">fund_freq = freqs[pows.argmax()]</span><br><span class="line"><span class="comment"># Use &#x27;where&#x27; function to find the index that we want to remove, that means if the indices is not equal to our frequency with maximal power,</span></span><br><span class="line"><span class="comment"># then these index can be regarded as the index of noise</span></span><br><span class="line">noised_indices = np.where(freqs!=fund_freq)</span><br><span class="line">filter_complex_array = complex_array.copy()</span><br><span class="line">filter_complex_array[noised_indices] = <span class="number">0</span></span><br><span class="line">filter_pows = np.<span class="built_in">abs</span>(filter_complex_array)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Frequency&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Power&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">plt.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">plt.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.plot(freqs[freqs &gt;= <span class="number">0</span>], filter_pows[freqs &gt;= <span class="number">0</span>], c=<span class="string">&#x27;dodgerblue&#x27;</span>, label=<span class="string">&#x27;Filtered&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Used the ifft to transform the signal in frequency domain to time domain</span></span><br><span class="line">filter_sigs = np.fft.ifft(filter_complex_array).real</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time&#x27;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Signal&#x27;</span>,fontsize = <span class="number">12</span>)</span><br><span class="line">plt.tick_params(labelsize=<span class="number">10</span>)</span><br><span class="line">plt.grid(linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.plot(times[:<span class="number">178</span>], filter_sigs[:<span class="number">178</span>], c=<span class="string">&#x27;hotpink&#x27;</span>, label=<span class="string">&#x27;clean&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># write the new clean signal.</span></span><br><span class="line">wavfile.write(<span class="string">&#x27;clean_signal.wav&#x27;</span>, sample_rate, filter_sigs)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="更快的卷积方法（overlap-add和overlap-save"><a href="#更快的卷积方法（overlap-add和overlap-save" class="headerlink" title="更快的卷积方法（overlap-add和overlap-save)"></a>更快的卷积方法（overlap-add和overlap-save)</h4><p>虽然我们之前用分而治之的思想提出的FFT算法已经能够实现很快的卷积运算了，但是其还是要求我们输入输入信号$x(n)$的全部数据，那么就会有一些问题： 1、如果输入信号$x(n)$ 很长，那么此时FFT运算会耗费非常多的内存资源，对于算力较小的机器限制较大。 2、在实际的实时运算当中，我们并没有方法能够得到全部的$x(n)$ 数据，所以要考虑分块来进行卷积的方法，比如囤积了512&#x2F;256&#x2F;128个数据时，那么就进行一次卷积，这就能够满足实时性的要求，最后再按照相应规则，将子序列的卷积结果拼接起来，就可以得到最后的结果。</p>
<h5 id="Overlap-add"><a href="#Overlap-add" class="headerlink" title="Overlap-add"></a>Overlap-add</h5><p>其基本思路是将输入序列 $x(n)$ 按照时间顺序分割为多段长度为$L$ 的子序列$x_k(n)$, 并通过计算每个子序列$x_k(n)$ 与冲激响应$h(n)$ 的卷积结果，也就是$y_k(n) &#x3D; x_k(n) * h(n)$ ，最终将每个$y_k(n)$ 按照一定的规律重叠相加，最终可以得到$x(n)$ 与$h(n)$ 的卷积结果。</p>
<p>推导过程如下：假设脉冲响应$h(n)$ 为有限长序列，序列长度为$M$， 而输入信号序列$x(n)$ 为无限长或者序列长度很大的信号序列，那么根据卷积运算的定义，二者之间的卷积计算为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226091806824.png" alt="image-20230226091806824" style="zoom: 33%;" />

<p>那么现在我们将输入信号$x(n)$分割为长度为$L$ 的小段，那么就有：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226091910201.png" alt="image-20230226091910201" style="zoom: 33%;" />

<p>那么原始输入序列$x(n)$ 与子序列$x_k(n)$ 之间的关系就是：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226091942453.png" alt="image-20230226091942453" style="zoom: 33%;" />

<p>那么现在的$y(n)$ 就可以表示为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226092001785.png" alt="image-20230226092001785" style="zoom: 33%;" />

<p>又因为卷积运算的线性性质，那么就可以将上式进一步表示为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226092147443.png" alt="image-20230226092147443" style="zoom: 33%;" />

<p>也就是：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226092209104.png" alt="image-20230226092209104" style="zoom: 33%;" />

<p>那么，就可以看到对于此时的输出$y(n)$ 可以由$x(n)$ 的子序列$x_k(n)$ 与$h(n)$ 的卷积结果$y_k(n)$ 的叠加得到。所以在这里为了更快的进行卷积运算，还是考虑运用FFT将信号从时域变换到频域进行卷积运算。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226092458317.png" alt="image-20230226092458317" style="zoom:50%;" />

<p>其主要算法在于：</p>
<ul>
<li>将长时间输入信号$x(n)$分为块，每个块的大小为2的幂次方（让FFT效率更高），对于最后一个块，采用zero-padding使其大小与其他块相同。</li>
<li>将每个块进行FFT变换</li>
<li>将脉冲响应（卷积核）也进行FFT变换</li>
<li>在频域进行乘积</li>
<li>每个块的结果进行IFFT变换，变回到时域</li>
<li>将相邻块之间的重叠区域相加，得到最终的输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to implement overlap method to speed up convolution</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> generate_sin_signal <span class="keyword">import</span> generate_sinusoid</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> FFT_convolution <span class="keyword">import</span> fft_convolution</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overlap_add_convlution</span>(<span class="params">x, h, B = <span class="number">64</span>, K=<span class="literal">None</span></span>):</span><br><span class="line">    M = <span class="built_in">len</span>(x)</span><br><span class="line">    N = <span class="built_in">len</span>(h)</span><br><span class="line"></span><br><span class="line">    num_input_blocks = np.ceil(M / B).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    output_size = M + N - <span class="number">1</span></span><br><span class="line">    y = np.zeros((output_size,))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num_input_blocks):</span><br><span class="line">        xb = x[n * B:(n + <span class="number">1</span>) * B]</span><br><span class="line"></span><br><span class="line">        u = fft_convolution(xb, h, K)</span><br><span class="line"></span><br><span class="line">        y[n * B:n * B + <span class="built_in">len</span>(u)] += u</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    N = <span class="number">10000</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">440</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    t = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    n = np.arange(<span class="number">0</span>, <span class="number">0.02</span>, <span class="number">1</span> / fs)</span><br><span class="line"></span><br><span class="line">    phi = <span class="number">0</span></span><br><span class="line">    x = generate_sinusoid(N, A, f0, fs, phi)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test02</span>():</span><br><span class="line">    N = <span class="number">512</span></span><br><span class="line">    A = <span class="number">0.8</span></span><br><span class="line">    f0 = <span class="number">100</span></span><br><span class="line">    fs = <span class="number">44100</span></span><br><span class="line">    t = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    n = np.arange(<span class="number">0</span>, <span class="number">0.02</span>, <span class="number">1</span> / fs)</span><br><span class="line"></span><br><span class="line">    phi = <span class="number">0</span></span><br><span class="line">    x = generate_sinusoid(N, A, f0, fs, phi)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;sin wave&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    x = test01()  <span class="comment"># generate the sin signal with frequency 440Hz</span></span><br><span class="line">    h = test02()</span><br><span class="line">    a = time.perf_counter()</span><br><span class="line">    y = np.convolve(x,h)</span><br><span class="line">    b = time.perf_counter()</span><br><span class="line">    t1 = b-a</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;使用numpy的convolve所花时间为%f&quot;</span> %t1)</span><br><span class="line">    c = time.perf_counter()</span><br><span class="line">    y2 = overlap_add_convlution(x,h)</span><br><span class="line">    d = time.perf_counter()</span><br><span class="line">    t2 =d -c</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;使用overlap-add所花时间为%f&quot;</span> % t2)</span><br></pre></td></tr></table></figure>



<h5 id="Overlap-save"><a href="#Overlap-save" class="headerlink" title="Overlap-save"></a>Overlap-save</h5><p>其基本思路核overlap-add方法相似，也是将$x(n)$ 在时间上分割成等长的子序列$x_k(n)$，计算每个子序列$x_k(n)$与$h(n)$的卷积结果$y_k(n) &#x3D; x_k(n)<em>h(n)$，不同之处在于 ：*<em>其将每个$y_k(n)$ 按照一定的规律保留其中某些项，丢弃另外项，组成$y(n)$</em></em> ，与OLA不同的是，OLS选取的分割长度为$L+M-1$。并且这种算法算出的输出区块并不重叠（计算上少了将输出区块相加所需的加法运算），而是每次使用的输入区块有所重叠，因此实现时每次读取输入后需将核下一个输入重叠的部分存储起来，作为下一输入区块的开头部分。</p>
<p>那么按照上面的规则，那么我们可以对序列$x(n)$ 进行分段：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226210354488.png" alt="image-20230226210354488" style="zoom: 50%;" />

<p>那么在区间$[kL+1,(k+1)L]$内的n，输出$y(n)$ 可以表示为：</p>
<p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226210726777.png" alt="image-20230226210726777"></p>
<p>那么我们只需要计算$n$ 在$[M+1,L+M]$的$y_k[n]$ 部分即可。因此每一段输出区块$y_k[n]$ 的前$M-1$个点可以丢弃(discard)，保留剩余$L$ 点的数值。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226211138438.png" alt="image-20230226211138438" style="zoom: 50%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226211336580.png" alt="image-20230226211336580" style="zoom: 67%;" />

<p>如果此时我们将$x_k[n]$做$N\geq L+M-1$ 的周期延拓，</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226211458196.png" alt="image-20230226211458196" style="zoom: 50%;" />

<p>那么$x_{k,N}<em>h$和$x_k</em>h$这两个卷积在$[M+1,L+M]$的部分相等，所以可以将线性卷积变成$N$ 点的循环卷积进行计算。结果的$[M+1,L+M]$ 部分作为输出$y[n]$在$[M+1,L+M]$ 的部分。那么由于循环卷积定理，<strong>两个离散序列的循环卷积的傅里叶变换等于这两个序列在频域内的点积</strong>。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230226211953422.png" alt="image-20230226211953422" style="zoom: 50%;" />

<p>那么此时就可以变成三次$N$点快速傅里叶变换和$N$ 次乘法，使得原本每段$O(N^2)$的运算量减少至$O(NlogN)$，可以提升很高的运算速度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">overlap_save_convolution</span>(<span class="params">x,h,B,K=<span class="literal">None</span></span>):</span><br><span class="line">    M = <span class="built_in">len</span>(x)</span><br><span class="line">    N = <span class="built_in">len</span>(h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> K <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        K = next_power_of_2(B+N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the number of input blocks</span></span><br><span class="line">    num_input_blocks = np.ceil(M/B).astype(<span class="built_in">int</span>) + np.ceil(K/B).astype(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pad zeros</span></span><br><span class="line">    xp = pad_zeros_to(x,num_input_blocks*B)</span><br><span class="line">    output_size = num_input_blocks * B+N-<span class="number">1</span></span><br><span class="line">    y = np.zeros((output_size,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input buffer</span></span><br><span class="line">    xw = np.zeros((K,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convolve all blocks</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num_input_blocks):</span><br><span class="line">        <span class="comment"># Extract the n-th input block</span></span><br><span class="line">        xb = xp[n*B:n*B+B]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sliding window of the input</span></span><br><span class="line">        xw = np.roll(xw,-B)</span><br><span class="line">        xw[-B:] = xb</span><br><span class="line"></span><br><span class="line">        <span class="comment"># FFT</span></span><br><span class="line">        u = fft_convolution(xw,h,K)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save the valid output samples</span></span><br><span class="line">        y[n*B:n*B+B] = u[-B:]</span><br><span class="line">    <span class="keyword">return</span> y[:M+N-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="5、短时傅里叶变换-STFT"><a href="#5、短时傅里叶变换-STFT" class="headerlink" title="5、短时傅里叶变换 STFT"></a>5、短时傅里叶变换 STFT</h2><h3 id="短时傅里叶变换是什么？我们为什么要用它？"><a href="#短时傅里叶变换是什么？我们为什么要用它？" class="headerlink" title="短时傅里叶变换是什么？我们为什么要用它？"></a>短时傅里叶变换是什么？我们为什么要用它？</h3><p>在我们之前所介绍的傅里叶变换等都是针对平稳信号的，但是在很多实际应用中的信号均为非平稳的，如果要计算其傅里叶变换，需要假设其周期无限长，然后对这个无限长的信号做变换分析。但是我们在实际过程中并不能实现这种无限长信号的分析，我们只能对有限长的局部信号进行分析，且被分析的有限长局部信号需满足两个条件：1、信号在截取这段时间内是平稳的 。2、在局部平稳信号中包含至少1个完整的周期。</p>
<p>因此我们可以考虑截取非平稳信号的局部平稳信号，然后采用傅里叶变换进行频域分析，这种方法便就是短时傅里叶变换。</p>
<hr>
<p><strong>什么是平稳信号：</strong></p>
<p>随机信号是随机过程，其每个时间点都是随机变量，随机变量并没有确定值，只有在每次观测过程中得到的一组观测值，那么我们只能通过对随机变量进行统计观测，才能对其的概率分布进行估计。所以对于随机信号来说，无论是否平稳，我们都从其的统计学特性来考虑。</p>
<p>平稳信号包含的信息量小，其统计特性不随时间变化，统计特性不变，也就是说在对平稳随机信号进行一定的时间观测后，就不需要其后续的观测了，因为此时信号的全部统计信息已经被获得了。平稳随机信号在不同时刻的期望值相同，或者表达成为其自相关函数只与时间间隔相关。也就是可以把平稳随机信号看作为在直流信号上加上看似随机波动的波形。比如直流加白噪声。</p>
<p>而对于非平稳随机信号，其统计特性随着时间在变，其信息量是变化的，始终会有“新息”引入，而“新息”主要指的就是当前信号的值与预测信号值的差值。预测信号是根据过去信号的统计特性推测出来的，“新息”具有不可预测的部分。如f(t) &#x3D; t这个确定信号叠加白噪声，其就是非平稳信号。而对于语音信号来说，有时是短时平稳（人声的浊声），但是总体呈现的是非平稳的。[<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/sep-5/posts#ref_1">1]</a>对于平稳随机信号，比较显著的就是高斯噪声。</p>
<hr>
<p>然而，在我们截取原始的非平稳信号时，如果信号截断为非周期截断，那么频谱将发生泄漏，所以通过引入一种窗函数，通过加窗，可以减少频谱的泄漏，换句话来说，也就是窗函数可以将一个非周期的信号，强行转变为一个周期信号。在时域加窗表现为信号与窗函数的点乘，而在频域表示为信号的卷积。假设时域信号为$x$,生成窗函数为$w$，那么加窗后的信号为$x &#x3D; x\cdot w$。</p>
<h3 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h3><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227093348260.png" alt="image-20230227093348260" style="zoom:33%;" />

<p>上图便是对于窗函数的一个演示，即对一个$cos$ 信号加上$hamming$ 窗，其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This script is used implement the window function</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">M = <span class="number">128</span>     <span class="comment"># The length of signal</span></span><br><span class="line">x = np.cos(np.linspace(<span class="number">0</span>,<span class="number">8</span>*np.pi,<span class="number">128</span>))    <span class="comment"># Generate cos signal</span></span><br><span class="line">w = get_window(<span class="string">&#x27;hamming&#x27;</span>,M)    <span class="comment"># call the window function , generate w (hamming window)</span></span><br><span class="line"></span><br><span class="line">xw = x*w</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">311</span>)</span><br><span class="line">plt.plot(x)</span><br><span class="line">plt.title(<span class="string">&#x27;Input signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">312</span>)</span><br><span class="line">plt.plot(w)</span><br><span class="line">plt.title(<span class="string">&quot;Hamming window&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">313</span>)</span><br><span class="line">plt.plot(xw)</span><br><span class="line">plt.title(<span class="string">&quot;window signal&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>那么在前一节提到了，窗函数是被用来削弱我们对非平稳信号非周期截断时引起的频谱泄漏，那么频谱泄漏就可以理解为，我们对信号进行非周期截断，截断后的信号起始时刻和结束时刻的幅值明显不等，我们再对这个信号进行重构时，再连接处信号的幅值不连续，出现跳跃。那么变换到频域上也就是说，这个频点的能量泄漏到了旁边其他频率上去，造成了频谱的在频带上的拖尾现象，关于频谱泄漏的进一步解释可以参考这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI5NTM0MTQwNA==&mid=2247484164&idx=1&sn=fdaf2164306a9ca4166c2aa8713cacc5&scene=21#wechat_redirect">什么是泄漏？ (qq.com)</a>。</p>
<p>通过代码生成了一段$cos$信号，并观察加窗后对其在频谱的频谱泄漏的抑制情况。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227094815299.png" alt="image-20230227094815299" style="zoom: 33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This script is used to demonstrate what is frequency leakage</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">M = <span class="number">128</span>     <span class="comment"># The length of signal</span></span><br><span class="line">x = np.cos(np.linspace(<span class="number">0</span>,<span class="number">100</span>*np.pi,<span class="number">128</span>))    <span class="comment"># Generate cos signal</span></span><br><span class="line">w = get_window(<span class="string">&#x27;hamming&#x27;</span>,M)    <span class="comment"># call the window function , generate w (hamming window)</span></span><br><span class="line"></span><br><span class="line">X = fft(x)</span><br><span class="line">mX = np.<span class="built_in">abs</span>(X)</span><br><span class="line"></span><br><span class="line">xw = x*w</span><br><span class="line">XW = fft(xw)</span><br><span class="line">mXW = np.<span class="built_in">abs</span>(XW)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x);plt.title(<span class="string">&#x27;(a)Input signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(xw);plt.title(<span class="string">&#x27;(b)Windowed signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(mX);plt.title(<span class="string">&#x27;(c)Amplitude of unwindowed signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(mXW);plt.title(<span class="string">&#x27;(d)Amplitude of windowed signal&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>对于窗函数的要求：一个理想的窗函数在频域的主瓣应该非常窄，有足够的频率分辨率。而旁瓣又能尽可能低，使得对其余频点的能量泄漏尽可能少。但是在实际中，我们不能同时坐到主瓣和旁瓣性能最优，需要在这两者之间取得一个性能的折中。常见的窗函数有矩形窗，Hanning，Hamming，Blackman,Chebyshev等。我们常用$scipy.signal$ 中的$get -window$ 来生成窗函数。 详情可以看<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html">scipy.signal.get_window — SciPy v1.10.1 Manual</a></p>
<h4 id="矩形窗："><a href="#矩形窗：" class="headerlink" title="矩形窗："></a>矩形窗：</h4><p>主瓣集中，频率分辨率较高，但是旁瓣较高，主瓣宽度：2bins, 旁瓣高度：-13.3dB</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227095231588.png" alt="image-20230227095231588" style="zoom: 33%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227100012558.png" alt="image-20230227100012558" style="zoom:33%;" />

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This script is used to implement the rectangular window function</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft,fftshift</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">w = signal.boxcar(<span class="number">51</span>)</span><br><span class="line">W = fft(w,<span class="number">2048</span>)</span><br><span class="line">freq = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="built_in">len</span>(W))</span><br><span class="line">response = <span class="number">20</span>*np.log10(np.<span class="built_in">abs</span>(fftshift(W/np.<span class="built_in">abs</span>(W).<span class="built_in">max</span>())))</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(w)</span><br><span class="line">plt.title(<span class="string">&#x27;Rectangular window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sample&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(freq,response)</span><br><span class="line">plt.axis([-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">120</span>,<span class="number">0</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Frequency response of the rectangular window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Normalised magnitude(dB)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Normalised frequency&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="Hanning窗（升余弦窗）"><a href="#Hanning窗（升余弦窗）" class="headerlink" title="Hanning窗（升余弦窗）"></a>Hanning窗（升余弦窗）</h4><p>主瓣更宽，频率分辨率下降，旁瓣减小，频谱泄漏减小。 主瓣宽度：4bins, 旁瓣高度：-31.5dB</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227100308364.png" alt="image-20230227100308364" style="zoom: 33%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227101018518.png" alt="image-20230227101018518" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This script is used to implement the rectangular window function</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft,fftshift</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">w = signal.hanning(<span class="number">51</span>)</span><br><span class="line">W = fft(w,<span class="number">2048</span>)</span><br><span class="line">freq = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="built_in">len</span>(W))</span><br><span class="line">response = <span class="number">20</span>*np.log10(np.<span class="built_in">abs</span>(fftshift(W/np.<span class="built_in">abs</span>(W).<span class="built_in">max</span>())))</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(w)</span><br><span class="line">plt.title(<span class="string">&#x27;Hanning window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sample&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(freq,response)</span><br><span class="line">plt.axis([-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">120</span>,<span class="number">0</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Frequency response of the hanning window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Normalised magnitude(dB)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Normalised frequency&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="Hamming-改进升余弦窗"><a href="#Hamming-改进升余弦窗" class="headerlink" title="Hamming: 改进升余弦窗"></a>Hamming: 改进升余弦窗</h4><p>相对Hanning窗来说，旁瓣更小，但是旁瓣衰减速度变慢。主瓣宽度：4bins, 旁瓣高度：-42.7dB</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227101159158.png" alt="image-20230227101159158" style="zoom: 33%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227101251818.png" alt="image-20230227101251818" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This script is used to implement the rectangular window function</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft,fftshift</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">w = signal.hamming(<span class="number">51</span>)</span><br><span class="line">W = fft(w,<span class="number">2048</span>)</span><br><span class="line">freq = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="built_in">len</span>(W))</span><br><span class="line">response = <span class="number">20</span>*np.log10(np.<span class="built_in">abs</span>(fftshift(W/np.<span class="built_in">abs</span>(W).<span class="built_in">max</span>())))</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(w)</span><br><span class="line">plt.title(<span class="string">&#x27;Hamming window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sample&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(freq,response)</span><br><span class="line">plt.axis([-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">120</span>,<span class="number">0</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Frequency response of the hamming window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Normalised magnitude(dB)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Normalised frequency&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="Blackman窗（二阶升余弦窗）"><a href="#Blackman窗（二阶升余弦窗）" class="headerlink" title="Blackman窗（二阶升余弦窗）"></a>Blackman窗（二阶升余弦窗）</h4><p>主瓣宽，旁瓣比较低。主瓣宽度：6bins, 旁瓣高度：-58dB</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227101525377.png" alt="image-20230227101525377" style="zoom: 33%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230227101520115.png" alt="image-20230227101520115" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### This script is used to implement the rectangular window function</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> get_window</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft,fftshift</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">w = signal.blackman(<span class="number">51</span>)</span><br><span class="line">W = fft(w,<span class="number">2048</span>)</span><br><span class="line">freq = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="built_in">len</span>(W))</span><br><span class="line">response = <span class="number">20</span>*np.log10(np.<span class="built_in">abs</span>(fftshift(W/np.<span class="built_in">abs</span>(W).<span class="built_in">max</span>())))</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(w)</span><br><span class="line">plt.title(<span class="string">&#x27;blackman window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sample&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(freq,response)</span><br><span class="line">plt.axis([-<span class="number">0.5</span>,<span class="number">0.5</span>,-<span class="number">120</span>,<span class="number">0</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Frequency response of the blackman window&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Normalised magnitude(dB)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Normalised frequency&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="STFT的原理及实现："><a href="#STFT的原理及实现：" class="headerlink" title="STFT的原理及实现："></a>STFT的原理及实现：</h3><p>关于STFT的原理，可以参考这篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351634228">STFT(短时傅里叶变换)的原理与使用 - 知乎 (zhihu.com)</a>，在短时傅里叶变换过程中，窗的长度决定频谱的时间分辨率和频率分辨率，窗长越长，截取的信号越长，信号越长，傅里叶变换后的频率分辨率越高，时间分辨率越差，相反，窗长越短，截取的信号就越短，频率分辨率越差，时间分辨率就越好，也就是说，在短时傅里叶变换中，时间分辨率和频率分辨率不能兼得，只能在中间根据具体需求取得一个折中。 原理可以看下方图片：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228095716887.png" alt="image-20230228095716887" style="zoom: 50%;" />

<p>计算短时傅里叶变换，我们需要指定的参数有：</p>
<ul>
<li>每个窗口的长度：$win$_$length$ </li>
<li>每相邻两个窗口的重叠率：$hop$_$length$</li>
<li>每个窗口的FFT采样点数：$n$_$fft$</li>
<li>窗函数：$w$</li>
<li>信号被分成了多少片</li>
<li>spectrogram</li>
</ul>
<p>关于STFT的实现，我们可以使用$librosa.stft$ 来计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">librosa.stft(y, n_fft=<span class="number">2048</span>, hop_length=<span class="literal">None</span>, win_length=<span class="literal">None</span>, window=<span class="string">&#x27;hann&#x27;</span>, center=<span class="literal">True</span>, pad_mode=<span class="string">&#x27;reflect&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其中的参数：</p>
<ul>
<li><strong>$y$</strong>:   输入音频序列</li>
<li>$n$_$fft$: FFT 窗口大小， ：n_fft &#x3D; hop_length + overlapping</li>
<li>hop_length : 帧移， 若未指定，一般默认为 win_length&#x2F;4</li>
<li>win_length:  分割好的每一帧音频都由window()加窗。 窗长 win_length,  并zero-padding 来匹配 n_fft，默认win_length &#x3D; n_fft</li>
<li>window: 指定窗函数具体参数</li>
<li>center: bool<ul>
<li>如果为True, 则填充信号y,以使帧D[:,t] 以 y[t * hop_length ]为中心</li>
<li>如果为False, 则D[:,t] 以 y[t * hop_length]  开始</li>
</ul>
</li>
<li>pad_mode:  如果center &#x3D; true, 那么在信号边缘用填充模式， 默认情况下使用 reflection padding</li>
</ul>
<p>返回值：</p>
<ul>
<li>STFT 矩阵 D, shape &#x3D; (1+$\frac{n_{fft}}{2},t$)</li>
</ul>
<p>对于语音”Please call Stella” 的time domain 和 STFT domain 图和code如下：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228093542215.png" alt="image-20230228093542215" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## This script is used to transfer the signal from time domain into STFT domain</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line">signal, sample_rate = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D = librosa.stft(signal,n_fft = <span class="number">512</span>, hop_length = <span class="literal">None</span>, win_length = <span class="literal">None</span>, window = <span class="string">&#x27;hann&#x27;</span>,center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(D.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># divide into magnitude and phase</span></span><br><span class="line">magnitude, phase = librosa.magphase(D, power= <span class="number">1</span>)</span><br><span class="line">angle = np.angle(phase)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the time domain and stft domain</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># time domain</span></span><br><span class="line">librosa.display.waveshow(signal,sample_rate)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;time domain&#x27;</span>)</span><br><span class="line"><span class="comment"># STFT domain</span></span><br><span class="line">plt.figure()</span><br><span class="line">STFT = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(D),ref= np.<span class="built_in">max</span>)</span><br><span class="line">img = librosa.display.specshow(STFT,sr = sample_rate, x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;STFT domain&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>





<h3 id="Mel频谱以及Mel倒谱系数（MFCC）"><a href="#Mel频谱以及Mel倒谱系数（MFCC）" class="headerlink" title="Mel频谱以及Mel倒谱系数（MFCC）"></a>Mel频谱以及Mel倒谱系数（MFCC）</h3><p>在上一节当中，我们通过STFT将语音信号从时域变换到了STFT域，并且得到了对应的spectrogram, 频谱表示频率和能量的关系，通过观察功率谱可以清晰的看到语音信号中的共振峰等语音特征，其在语音识别等领域有很好的作用，但是因为频谱图是一个包含有原始信号信息的频域表示，为了尽量减少数据大小，降低计算复杂度，得到合适大小的声音特征，我们往往将其通过梅尔标度滤波器组（mel-scale filter banks)变换为梅尔频谱，那么什么是梅尔滤波器组呢，这要从mel标度说起:</p>
<p>其基本思想与判断相同响度相同，mel 刻度是一种由听众判断不同频率的音高（pitch) 彼此相等的感知刻度，表示人耳对等距音高变化的感知，通俗点来说就是，人耳对频率的感知并不是线性的，我们的基底膜对低频信号彼此的区别更加敏感，对高频信号的区别不是那么敏感，也就是低频段上的两个频度和高频段的两个频度，人们更容易区分前者，频域上相等距离的两对频度，对人耳来说距离并不相等。例如：我们先听1000Hz的声音，如果我们把频率提高到2000Hz，那么我们的耳朵也只能觉察到频率提高了一点点，并不能觉察到频率提高了一倍。所以Mel刻度就被提出了，其用来调整频域的刻度，使得在这个刻度上相等距离的两对频度，在人耳感知中也相同。Mel 刻度和正常频率（Hz)之间的参考点是将1kHz,且高于人耳听阈值40dB以上的基音，定为1000mel。在大约500Hz以上，听者判断越来越大的音程产生相等的音调增量，然后最后发现，人耳感觉到的等量的音高变化，所需要的频率变化随频率增大而越来越大。</p>
<p>运用梅尔频谱可以将语音信号从线性频域转换到感知频域中，能够更好的模拟听觉过程的处理。</p>
<p>将频率$f(Hz)$ 转换到mel $m$ 的公式为：</p>
<p>​																						$$M &#x3D; 2595log_{10}(1+\frac{f}{700})$$ </p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228104509894.png" alt="image-20230228104509894" style="zoom: 33%;" />

<p>将梅尔$m$ 转换到频率$f(Hz)$ 的公式为：</p>
<p>​																								$$f &#x3D; 700e^{\frac{m}{2595}-1}$$</p>
<p>我们主要进行的处理就是：把进入人耳的声音频率用临界频带(critical Band) 进行划分，将语音在频域上划分为一系列的频率群，构成一个Mel滤波器组，因为人耳对不同频率的声波有敏感度，因为频率较低的声音在基底膜上行波传递距离大于频率较高的声音，因此低音容易掩蔽高音，且低音掩蔽的临界带宽相较高频小，<strong>所以研究人员从低频到高频按照临界频带的大小由密到疏设计了一组带通滤波器</strong>， 对输入信号进行滤波，将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后得到语音的输入特征。</p>
<p>什么是临界频带: 耳蜗的基底膜上有24个点能对24个不同频率产生最大幅度共振，从而将人耳可听频率范围$20Hz - 22kHz$ 分为24个频带，即为临界频带。</p>
<p>求MFCC的步骤：</p>
<ol>
<li>分帧、加窗</li>
<li>对于每一帧，计算功率谱的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Periodogram">周期图估计</a></li>
<li>将mel滤波器组应用于功率谱，求滤波器组的能量，将每个滤波器中的能量相加</li>
<li>取所有滤波器组能量的对数</li>
<li>取对数滤波器组能量的离散余弦变换（DCT）。</li>
<li>保持DCT系数2-13，其余部分丢弃</li>
</ol>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228114559250.png" alt="image-20230228114559250" style="zoom: 50%;" />

<h4 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h4><p>在这里预处理主要包括预加重、分帧、加窗。我们还是采用语音信号”Please call stella”</p>
<h5 id="①-预加重"><a href="#①-预加重" class="headerlink" title="① 预加重"></a>① 预加重</h5><p>我们对信号应用预加重滤波器来放大高频，主要是为了</p>
<ul>
<li>平衡频谱，因为高频声相较于低频声有较小幅度</li>
<li>改善信噪比（SNR）</li>
<li>消除发生过程中声带和嘴唇带来的高频抑制，突出高频的共振峰</li>
</ul>
<p>预加重就是将一个高通滤波器作用在语音信号上， 这里用：</p>
<img src="D:\Majority\算法\typora\image-20230228115115895.png" alt="image-20230228115115895" style="zoom:50%;" />

<p>其中滤波器系数($\alpha$) 通常取0.95或者0.97，下图为原始信号和加重后的信号对比。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228115327339.png" alt="image-20230228115327339" style="zoom: 50%;" />



<h5 id="②、分帧"><a href="#②、分帧" class="headerlink" title="②、分帧"></a>②、分帧</h5><p>和之前在STFT介绍的一样，因为语音信号是非平稳信号，我们不能直接对其使用DFT，所以考虑将信号分帧称为短时平稳信号，并</p>
<p>在短帧上进行傅里叶变换，我们将截取20-40ms的帧，一般采用frame_size &#x3D; 0.025s。帧移通常设置为10ms， frame_stride &#x3D; 0.01，为了避免相邻两帧的变化过大，我们让两个相邻的帧之间有一段重叠的区域，一般为每帧的1&#x2F;2或者1&#x2F;3，我们设置overlap &#x3D; 0.015s （15ms)， 如果没有划分为偶数个数的帧，那么就用zero-padding。</p>
<h5 id="③、加窗-window"><a href="#③、加窗-window" class="headerlink" title="③、加窗 (window)"></a>③、加窗 (window)</h5><p>原理和STFT节中所提及相同，为了平滑截断所造成的不连续性，引入了窗函数，详细说明请往前翻</p>
<h4 id="2、FFT"><a href="#2、FFT" class="headerlink" title="2、FFT"></a>2、FFT</h4><p>之后对每个加窗后的信号帧用FFT转换到频域来计算频谱，其中NFFT &#x3D; 512</p>
<h4 id="3、功率谱"><a href="#3、功率谱" class="headerlink" title="3、功率谱"></a>3、功率谱</h4><p>之后运用以下公式计算信号的功率谱，对语音信号的频谱取模平方</p>
<p>​																								$$		P &#x3D; \frac{|FFT(x_i)|^2}{N}$$</p>
<h4 id="4、Mel-刻度滤波器组"><a href="#4、Mel-刻度滤波器组" class="headerlink" title="4、Mel 刻度滤波器组"></a>4、Mel 刻度滤波器组</h4><p>将功率谱通过一组Mel刻度(通常为40个滤波器，nfilt &#x3D; 40) 的三角滤波器组来提取频带，低频处滤波器密集，门限值大，高频处滤波器稀疏，门限值低。正好能够模拟人耳对声音的非线性感知，对较低的频率有更强的辨别力。</p>
<p>滤波器组中的每个滤波器都是三角形的，中心频率为f(m)，中心频率处的响应为1，并向0线性减小，直到达到两个相邻滤波器的中心频率，其中此处响应为0，各f(m)之间的间隔随着$m$ 值得增大而变宽。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228125825958.png" alt="image-20230228125825958" style="zoom: 50%;" />

<p>三角形滤波器的频率响应为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228125845998.png" alt="image-20230228125845998" style="zoom:50%;" />

<p>对于我们刚刚STFT得到的幅度谱，我们将其分别跟每一个滤波器进行频率相乘累加，得到的值就是该帧数据在该滤波器对应的频段的能量值。如果滤波器的个数为40，那么就应该得到40个能量值。</p>
<p>那么可以看到信号的功率谱经过滤波器组后，得到的频谱图和原始频谱图的对比</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228130647454.png" alt="image-20230228130647454" style="zoom:50%;" />





<h4 id="5、Mel-频率倒谱系数（MFCC）"><a href="#5、Mel-频率倒谱系数（MFCC）" class="headerlink" title="5、Mel 频率倒谱系数（MFCC）"></a>5、Mel 频率倒谱系数（MFCC）</h4><p>在实际应用中，在上一节中计算的滤波器组系数是高度相关的，在一些机器学习算法中会有一些问题，所以我们可以应用离散余弦变换（DCT）对滤波器组系数去相关处理，得到滤波器组的压缩表示（这一块和稀疏感知相关）。对于自动语音识别技术（ASR），一般保留所得到的倒谱系数个数为2~13之间，并丢弃其余部分（丢弃的这部分系数会代表滤波器组系数的快速变化，这种精细的特征对ASR无帮助，故舍弃）。我们这里考虑num_ceps &#x3D; 12。 (注意使用DCT有很大限制：因为DCT是一种线性变换，在语音信号中丢弃一些高度非线性的信息是不可取的。)</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228131227037.png" alt="image-20230228131227037" style="zoom:50%;" />

<p>这是所得到的MFCC：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230228131318449.png" alt="image-20230228131318449" style="zoom:50%;" />

<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Python 可以调用$librosa$库直接提取Mel频谱和MFCC：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mel_spec = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=<span class="number">128</span>, fmax=<span class="number">8000</span>)</span><br><span class="line">mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=<span class="number">40</span>)</span><br></pre></td></tr></table></figure>



<p>下面是上述理论过程的一个代码实现和总结</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这个代码是用来熟悉mfcc的</span></span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> dct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取音频代码1，利用librosa库来读取</span></span><br><span class="line">data1, sampling_rate1 = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line"><span class="comment"># 读取音频代码2</span></span><br><span class="line"><span class="comment"># from scipy.io import wavfile</span></span><br><span class="line"><span class="comment"># sample_rate, signal = wavfile.read(&#x27;speech@24kHz.wav&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看波形图</span></span><br><span class="line">plt.figure()</span><br><span class="line">librosa.display.waveshow(data1*<span class="number">32767</span>,sr=sampling_rate1) <span class="comment"># librosa模块读取音频进行了归一化处理</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看声谱图</span></span><br><span class="line"><span class="comment"># 声谱图是声音或其他信号的频率随时间变化时的频谱(spectrum)的表示</span></span><br><span class="line">D = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(librosa.stft(data1,n_fft = <span class="number">512</span>)),ref=np.<span class="built_in">max</span>) <span class="comment"># 这里取librosa里的stft并用绝对值表示，ref用np的最大值</span></span><br><span class="line">librosa.display.specshow(D,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.colorbar(<span class="built_in">format</span> = <span class="string">&#x27;%+2.0f dB&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;linear-frequency power spectrogram of aloe&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 梅尔倒谱系数的定义</span></span><br><span class="line"><span class="comment"># 人耳对声音信号的感知聚焦在某一特定频率区域内，而并非在整个频谱包络中，耳蜗的滤波作用是在对数频率尺度下的</span></span><br><span class="line"><span class="comment"># 其在1000Hz以下为线性，1000以上为对数，人耳对低频比高频更敏感</span></span><br><span class="line"><span class="comment"># 人类对语音信号的频率内容的感知遵循主观定义的非线性尺度，其被称为&#x27;Mel&#x27;尺度</span></span><br><span class="line"><span class="comment"># Mel是音调的单位，其反应出了频率与音调的非线性关系</span></span><br><span class="line"><span class="comment"># MFCC将人耳的听觉感知特性和语音产生机制结合，主要在于对频率轴不均匀的划分</span></span><br><span class="line"><span class="comment"># Mel带通滤波器组的中心频率是按照Mel刻度均匀排列的。</span></span><br><span class="line"><span class="comment"># 滤波器集中在低频部分，在高频部分滤波器较少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MFCC的主要步骤</span></span><br><span class="line"><span class="comment"># 对语音信号进行预加重、分帧和加窗处理</span></span><br><span class="line"><span class="comment"># 对语音信号进行短时傅里叶变换 （短时傅里叶变换）</span></span><br><span class="line"><span class="comment"># 对功率谱用mel滤波器组进行滤波，计算每个滤波器里的能量（梅尔频谱）</span></span><br><span class="line"><span class="comment"># 然后对梅尔频谱进行取对数（log梅尔频谱）</span></span><br><span class="line"><span class="comment"># 再对其进行离散余弦变换，(梅尔倒谱)</span></span><br><span class="line"><span class="comment"># 保留变换后的2-13个系数，去掉其他的（MFCC特征）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预加重，分帧和加窗</span></span><br><span class="line"><span class="comment"># 1、读取音频</span></span><br><span class="line">signal, sample_rate = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line">signal *= <span class="number">32767</span> <span class="comment"># 因为librosa中读取的音频信号为归一化的信号，所以乘上32767还原信号原始幅值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(signal))</span><br><span class="line"></span><br><span class="line">axis_x = np.arange(<span class="number">0</span>,signal.size,<span class="number">1</span>)</span><br><span class="line">plt.plot(axis_x,signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Time domain plot&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、预加重</span></span><br><span class="line"><span class="comment"># 是为了放大高频，因为高频通常比低频有更小的幅值</span></span><br><span class="line"><span class="comment"># 避免在傅里叶变换过程中出现数值问题</span></span><br><span class="line"><span class="comment"># 改善信号信噪比（SNR）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用一阶滤波器应用在信号上 典型值为0.95或0.97</span></span><br><span class="line">pre_emphasis = <span class="number">0.97</span></span><br><span class="line">emphasized_signal = np.append(signal[<span class="number">0</span>],signal[<span class="number">1</span>]-pre_emphasis*signal[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">axis_x = np.arange(<span class="number">0</span>,emphasized_signal.size,<span class="number">1</span>)</span><br><span class="line">plt.plot(axis_x,emphasized_signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Pre_Emphasis&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、分帧</span></span><br><span class="line"><span class="comment"># 经过预加重后，要将信号分成短帧，因为信号中的频率会随时间变化，所以不能对整段信号进行傅里叶变换</span></span><br><span class="line"><span class="comment"># 假设信号的频率在很短的时间段内固定的，在短帧上进行傅里叶变换，并串联相邻帧来获得信号频率轮廓较好的近似</span></span><br><span class="line"><span class="comment"># 在语音信号处理中典型帧长度为20ms——40ms，并且连续帧之间有50%的overlap，设定帧为25ms，并且重叠15ms，帧移为10ms</span></span><br><span class="line">frame_stride = <span class="number">0.01</span>  <span class="comment"># 帧移为10ms</span></span><br><span class="line">frame_size = <span class="number">0.025</span> <span class="comment"># 帧长为25ms</span></span><br><span class="line">frame_length = frame_size * sample_rate <span class="comment"># 计算所有的采样点的总共帧长</span></span><br><span class="line">frame_step = frame_stride * sample_rate <span class="comment"># 计算所有采样点的总共帧移</span></span><br><span class="line">signal_length = <span class="built_in">len</span>(emphasized_signal)</span><br><span class="line">frame_length = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_length))</span><br><span class="line">frame_step = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_step))</span><br><span class="line"><span class="comment"># 向上取整求最后帧的数量，用信号长度减去帧长度再加上帧移长度除以帧移长度</span></span><br><span class="line">num_frames = <span class="built_in">int</span>(np.ceil(<span class="built_in">float</span>(np.<span class="built_in">abs</span>(signal_length-frame_length+frame_step))/frame_step))</span><br><span class="line"><span class="comment"># 又因为信号长度可能不是帧长整数倍，对原信号进行填充，至帧长的整数倍</span></span><br><span class="line">pad_signal_length = (num_frames - <span class="number">1</span>)* frame_step+frame_length</span><br><span class="line">z = np.zeros((pad_signal_length - signal_length))</span><br><span class="line">pad_signal = np.append(emphasized_signal,z)</span><br><span class="line"><span class="comment"># 之后将音频信号转化为二维矩阵，每一行就是一个音频帧的内容</span></span><br><span class="line">indices = np.tile(np.arange(<span class="number">0</span>,frame_length),(num_frames,<span class="number">1</span>))+np.tile(np.arange(<span class="number">0</span>,num_frames*frame_step,frame_step),(frame_length,<span class="number">1</span>)).T</span><br><span class="line"><span class="built_in">print</span>(indices.shape)</span><br><span class="line"><span class="comment"># 将补零后的信号转换为num_frames*frame_length的格式</span></span><br><span class="line">frames = pad_signal[indices.astype(np.int32,copy=<span class="literal">False</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、加窗</span></span><br><span class="line"><span class="comment"># 将信号切成帧后，对每个帧应用窗函数，抵消FFT的无限计算并减少频谱泄露</span></span><br><span class="line">frames = frames*np.hamming(frame_length)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、STFT，对每个帧上执行N点FFT来计算频谱，N通常为256或512</span></span><br><span class="line">NFFT = <span class="number">512</span></span><br><span class="line">mag_frames = np.<span class="built_in">abs</span>(np.fft.rfft(frames,NFFT))</span><br><span class="line">pow_frames = ((<span class="number">1.0</span>/NFFT)*((mag_frames)**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、对功率谱用Mel滤波器组进行滤波，计算每个滤波器里的能量，并对每个滤波器能量取log</span></span><br><span class="line"><span class="comment"># 因为声谱图中包含了许多无用的信息，我们用梅尔标度滤波器组将其变换为更简洁的梅尔频谱</span></span><br><span class="line"><span class="comment"># 梅尔尺度建立了从人类的听觉感知频率，也就是声调到声音直接频率的映射，因为人耳对Hz并不是线性感知关系</span></span><br><span class="line"><span class="comment"># 人耳对低频音调更敏感，而高频迟钝</span></span><br><span class="line"><span class="comment"># 梅尔滤波器组用26个三角滤波器组组成，对上一步得到的STFT进行滤波，并且区间频率越高，滤波器就越宽</span></span><br><span class="line"><span class="comment"># 将26个滤波器用一个矩阵表示，有26行</span></span><br><span class="line">nfilt = <span class="number">26</span></span><br><span class="line">low_freq_mel = <span class="number">0</span></span><br><span class="line">high_freq_mel = (<span class="number">2595</span>*np.log10(<span class="number">1</span>+(sample_rate/<span class="number">2</span>)/<span class="number">700</span>)) <span class="comment"># 从HZ转到mel</span></span><br><span class="line">mel_points = np.linspace(low_freq_mel,high_freq_mel,nfilt+<span class="number">2</span>) <span class="comment"># 这里划分nfilt+2个区域，因为一个三角滤波器实际上要占3个刻度</span></span><br><span class="line">hz_points = (<span class="number">700</span> * (<span class="number">10</span>**(mel_points/<span class="number">2595</span>)-<span class="number">1</span>)) <span class="comment"># 从mel转到hz</span></span><br><span class="line"><span class="built_in">bin</span> = np.floor((NFFT+<span class="number">1</span>)*hz_points/sample_rate) <span class="comment"># bin是响应的傅里叶变换点数</span></span><br><span class="line"><span class="comment"># fbank的shape是26*257，来储存每个滤波器的值</span></span><br><span class="line">fbank = np.zeros((nfilt,<span class="built_in">int</span>(np.floor(NFFT/<span class="number">2</span>+<span class="number">1</span>))))</span><br><span class="line"><span class="built_in">print</span>(fbank.shape)</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,nfilt+<span class="number">1</span>):</span><br><span class="line">    f_m_minus = <span class="built_in">int</span>(<span class="built_in">bin</span>[m-<span class="number">1</span>])</span><br><span class="line">    f_m = <span class="built_in">int</span>(<span class="built_in">bin</span>[m])</span><br><span class="line">    f_m_plus = <span class="built_in">int</span>(<span class="built_in">bin</span>[m+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(f_m_minus,f_m):</span><br><span class="line">        fbank[m-<span class="number">1</span>,k]=(k-<span class="built_in">bin</span>[m-<span class="number">1</span>])/(<span class="built_in">bin</span>[m]-<span class="built_in">bin</span>[m-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(f_m,f_m_plus):</span><br><span class="line">        fbank[m-<span class="number">1</span>,k]=(<span class="built_in">bin</span>[m+<span class="number">1</span>]-k)/(<span class="built_in">bin</span>[m+<span class="number">1</span>]-<span class="built_in">bin</span>[m])</span><br><span class="line"><span class="comment"># 将功率谱与滤波器做点积</span></span><br><span class="line">filter_banks = np.dot(pow_frames,fbank.T)</span><br><span class="line">filter_banks = np.where(filter_banks ==<span class="number">0</span>,np.finfo(<span class="built_in">float</span>).eps,filter_banks)</span><br><span class="line">filter_banks = <span class="number">20</span>*np.log10(filter_banks)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;filter banks&#x27;</span>)</span><br><span class="line">plt.imshow(np.flipud(filter_banks.T),cmap=plt.cm.jet,aspect=<span class="number">0.1</span>,extent=[<span class="number">0</span>,filter_banks.shape[<span class="number">1</span>],<span class="number">0</span>,filter_banks.shape[<span class="number">0</span>]])</span><br><span class="line">plt.xlabel(<span class="string">&quot;frames&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;dimension&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梅尔倒谱MFCCs,利用离散余弦变换，保留DCT的2-13个系数，产生滤波器组的压缩表示，丢弃的系数代表滤波器系数的快速变化，不太重要</span></span><br><span class="line"></span><br><span class="line">num_ceps = <span class="number">12</span></span><br><span class="line">mfcc = dct(filter_banks,<span class="built_in">type</span>=<span class="number">2</span>,axis=<span class="number">1</span>,norm=<span class="string">&#x27;ortho&#x27;</span>)[:,<span class="number">1</span>:(num_ceps+<span class="number">1</span>)] <span class="comment"># 保留</span></span><br><span class="line">cep_filter = <span class="number">22</span></span><br><span class="line">(nframes,ncoeff)=mfcc.shape</span><br><span class="line">n = np.arange(ncoeff)</span><br><span class="line">lift = <span class="number">1</span>+(cep_filter/<span class="number">2</span>)*np.sin(np.pi*n/cep_filter)</span><br><span class="line">mfcc=lift*mfcc</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;mfcc&#x27;</span>)</span><br><span class="line">plt.imshow(np.flipud(mfcc.T), cmap=plt.cm.jet, aspect=<span class="number">0.05</span>, extent=[<span class="number">0</span>, mfcc.shape[<span class="number">1</span>], <span class="number">0</span>, mfcc.shape[<span class="number">0</span>]])  <span class="comment"># 画热力图</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;Frames&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Dimension&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h2 id="6、语音数据增强"><a href="#6、语音数据增强" class="headerlink" title="6、语音数据增强"></a>6、语音数据增强</h2><p>我们在这里考虑对语音做一些增强，也就是对数据做一些较小的改动，主要是在于</p>
<ul>
<li>Noise addition (增加噪音)</li>
<li>Reverberation addition (增加混响)</li>
<li>Time shifting (时移)</li>
<li>Pitch shifting (改变音调)</li>
<li>Time stretching (拉伸时间)</li>
</ul>
<h3 id="一、导入原始语音数据"><a href="#一、导入原始语音数据" class="headerlink" title="一、导入原始语音数据"></a>一、导入原始语音数据</h3><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301103049826.png" alt="image-20230301103049826" style="zoom:50%;" />

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This script is used to do some simple speech enhancement</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line">signal,sample_rate = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line">spec = librosa.stft(signal,n_fft=<span class="number">512</span>,hop_length=<span class="literal">None</span>,win_length = <span class="literal">None</span>, window=<span class="string">&#x27;hann&#x27;</span>,center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the original signal</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">STFT = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec),ref=np.<span class="built_in">max</span>)</span><br><span class="line">img = librosa.display.specshow(STFT,sr = sample_rate,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Time domain&#x27;</span>)</span><br><span class="line">time = np.arange(<span class="number">0</span>,<span class="built_in">len</span>(signal))*(<span class="number">1.0</span>/sample_rate)</span><br><span class="line">plt.plot(time,signal)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;amplitude&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="二、增加噪声-Noise-addition-（时域）"><a href="#二、增加噪声-Noise-addition-（时域）" class="headerlink" title="二、增加噪声 (Noise addition)  （时域）"></a>二、增加噪声 (Noise addition)  （时域）</h3><p>这里考虑增加的噪声均为均值为0，标准差为1的高斯白噪声，那么我们有两种方法对数据进行加噪。</p>
<h4 id="①、控制噪声因子"><a href="#①、控制噪声因子" class="headerlink" title="①、控制噪声因子"></a>①、控制噪声因子</h4><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301103932036.png" alt="image-20230301103932036" style="zoom: 33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_noise1</span>(<span class="params">x, w= <span class="number">0.005</span></span>):</span><br><span class="line">    <span class="comment"># w: the noise coefficient</span></span><br><span class="line">    output = x + w*np.random.normal(loc = <span class="number">0</span>,scale = <span class="number">1</span>,size=<span class="built_in">len</span>(x))</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line"><span class="comment"># plot the editted signal</span></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">enhanced_STFT = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(enhanced_spec),ref=np.<span class="built_in">max</span>)</span><br><span class="line">enhanced_img = librosa.display.specshow(enhanced_STFT,sr = sample_rate,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram (add noise)&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Time domain (add noise)&#x27;</span>)</span><br><span class="line">time = np.arange(<span class="number">0</span>,<span class="built_in">len</span>(signal))*(<span class="number">1.0</span>/sample_rate)</span><br><span class="line">plt.plot(time,signal)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time/s&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;amplitude&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h4 id="②、控制信噪比"><a href="#②、控制信噪比" class="headerlink" title="②、控制信噪比"></a>②、控制信噪比</h4><p>我们有信噪比公式：<img src="D:\Majority\算法\typora\image-20230301104030090.png" alt="image-20230301104030090" style="zoom:50%;" /></p>
<p>可以根据信噪比公式来推导噪声并控制噪声。 此处我们设定SNR&#x3D; 20<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301105101995.png" alt="image-20230301105101995" style="zoom:33%;" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_noise2</span>(<span class="params">x,snr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param x:  The clean speech signal</span></span><br><span class="line"><span class="string">    :param snr:  The signal/noise ratio</span></span><br><span class="line"><span class="string">    :return:  The noisy speech signal with specific snr</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    P_signal = np.mean(x**<span class="number">2</span>)   <span class="comment"># the power of signal</span></span><br><span class="line">    k = np.sqrt(P_signal/<span class="number">10</span> ** (snr/<span class="number">10.0</span>))</span><br><span class="line">    <span class="keyword">return</span> x + np.random.randn(<span class="built_in">len</span>(x))*k</span><br></pre></td></tr></table></figure>





<h3 id="三、混响增强-Reverberation-addition-（时域）"><a href="#三、混响增强-Reverberation-addition-（时域）" class="headerlink" title="三、混响增强 (Reverberation addition)  （时域）"></a>三、混响增强 (Reverberation addition)  （时域）</h3><p>这里主要使用Image Source Method(镜像源方法) 来实现语音加混响，有两种方法实现，第一种是直接调用python库 ———-$Pyroomacoustics$ 来实现音频加混响，第二种是按照理论推导一步步实现音频加混响，可以通过第一种方法直接实现。</p>
<h4 id="方法一：Pyroomacoustic-库实现音频加混响"><a href="#方法一：Pyroomacoustic-库实现音频加混响" class="headerlink" title="方法一：Pyroomacoustic 库实现音频加混响"></a>方法一：Pyroomacoustic 库实现音频加混响</h4><ul>
<li>1、创建房间 （定义房间大小，所需混响时间，墙面材料，允许的最大反射次数）</li>
<li>2、在房间内创建信号源</li>
<li>3、在房间内放置麦克风</li>
<li>4、创建房间冲激响应</li>
<li>5、模拟声音传播</li>
</ul>
<p>调用Pyroomacoustic 库代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to add reverberation in the room</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyroomacoustics <span class="keyword">as</span> pra</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、create the room</span></span><br><span class="line"><span class="comment"># define the required reverberant time and the size of room</span></span><br><span class="line">rt60_tgt = <span class="number">0.5</span>  <span class="comment"># required reverberant time, s</span></span><br><span class="line">room_dim = [<span class="number">9</span>, <span class="number">7.5</span>, <span class="number">3.5</span>]  <span class="comment"># define a 9m x 7.5m x 3.5m &#x27;s room</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use sabine&#x27;s formula to calculate the energy absorbed by the wall and then maximum reflected number</span></span><br><span class="line">e_absorption, max_order = pra.inverse_sabine(rt60_tgt,room_dim)   <span class="comment"># return the energy absorbed by wall and the maximum reflected times</span></span><br><span class="line"><span class="comment"># by the way, we can define the wall&#x27;s material and the maximum reflected order</span></span><br><span class="line"><span class="comment"># m = pra.Material(energy_absorption = &quot;hard_surface&quot;)     # define different wall&#x27;s material</span></span><br><span class="line"><span class="comment"># max_order = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># simulate the room</span></span><br><span class="line">room = pra.ShoeBox(room_dim,fs=<span class="number">16000</span>,materials=pra.Material(e_absorption),max_order=max_order)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、create a source located at [2.5,3.73,1.76], radiated from 0.3s</span></span><br><span class="line">audio,_ = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>,sr = <span class="number">16000</span>)</span><br><span class="line">room.add_source([<span class="number">2.5</span>,<span class="number">3.73</span>,<span class="number">1.76</span>],signal = audio,delay=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、put the microphones in the room</span></span><br><span class="line"><span class="comment"># define the positions of the microphone:(ndim, nmics) Each columns includes one coordinate of microphone</span></span><br><span class="line"><span class="comment"># here we create an array with two microphones which locate at [6.3, 4.87, 1.2] and [6.3, 4.93, 1.2] respectively</span></span><br><span class="line">mic_locs = np.c_[</span><br><span class="line">    [<span class="number">6.3</span>,<span class="number">4.87</span>,<span class="number">1.2</span>],   <span class="comment"># mic1</span></span><br><span class="line">    [<span class="number">6.3</span>,<span class="number">4.93</span>,<span class="number">1.2</span>],   <span class="comment"># mic2</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># put the microphone into the room</span></span><br><span class="line">room.add_microphone_array(mic_locs)     <span class="comment"># put the microphone in the room</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、create the room impulse response</span></span><br><span class="line">room.compute_rir()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、simulate the propogation of the sound, and the signal from each source will convolve with corresponding rir, and the output</span></span><br><span class="line"><span class="comment"># will be summared based on microphone</span></span><br><span class="line">room.simulate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># store all the signal to &#x27;wav&#x27; file</span></span><br><span class="line">room.mic_array.to_wav(<span class="string">&#x27;./16kreverb_ISM.wav&#x27;</span>,norm = <span class="literal">True</span>,bitdepth = np.float32,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># measure the reverberant time</span></span><br><span class="line">rt60 = room.measure_rt60()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The desired RT60 was &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(rt60_tgt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The measured RT60 is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(rt60[<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># plot the RIR</span></span><br><span class="line">rir_1_0 = room.rir[<span class="number">1</span>][<span class="number">0</span>]      <span class="comment"># the RIR between mic 1 and source 0</span></span><br><span class="line">rir_2_0 = room.rir[<span class="number">0</span>][<span class="number">0</span>]      <span class="comment"># the RIR between mic 0 and source 0</span></span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(rir_1_0))/room.fs,rir_1_0)</span><br><span class="line">plt.title(<span class="string">&#x27;The RIR from source 0 to mic 1&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time [s]&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(rir_2_0))/room.fs,rir_2_0)</span><br><span class="line">plt.title(<span class="string">&#x27;The RIR from source 0 to mic 2&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time[s]&#x27;</span>)</span><br><span class="line"><span class="comment"># plt the signal receiving by microphone1 and microphone 0</span></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(room.mic_array.signals[<span class="number">1</span>,:]))/room.fs, room.mic_array.signals[<span class="number">1</span>,:])</span><br><span class="line">plt.title(<span class="string">&#x27;Microphone 1 signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(room.mic_array.signals[<span class="number">0</span>,:]))/room.fs, room.mic_array.signals[<span class="number">0</span>,:])</span><br><span class="line">plt.title(<span class="string">&#x27;Microphone 0 signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the original spectrogram</span></span><br><span class="line">spec_original = librosa.stft(audio,n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>, win_length = <span class="literal">None</span>, window=<span class="string">&#x27;hann&#x27;</span>,center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_original = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_original),ref=np.<span class="built_in">max</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">321</span>)</span><br><span class="line">img1 = librosa.display.specshow(stft_original,sr=<span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of clean signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">322</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(audio))/<span class="number">16000</span>,audio)</span><br><span class="line">plt.title(<span class="string">&#x27;clean signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the processed spectrogram (mic 0)</span></span><br><span class="line">spec_mic0 = librosa.stft(room.mic_array.signals[<span class="number">0</span>,:],n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>, win_length = <span class="literal">None</span>, window=<span class="string">&#x27;hann&#x27;</span>,center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_mic0 = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_mic0),ref=np.<span class="built_in">max</span>)</span><br><span class="line">plt.subplot(<span class="number">323</span>)</span><br><span class="line">img1 = librosa.display.specshow(stft_mic0,sr=<span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of mic 0&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">324</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(room.mic_array.signals[<span class="number">0</span>,:]))/room.fs, room.mic_array.signals[<span class="number">0</span>,:])</span><br><span class="line">plt.title(<span class="string">&#x27;Microphone 0 signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the processed spectrogram (mic 1)</span></span><br><span class="line">spec_mic1 = librosa.stft(room.mic_array.signals[<span class="number">1</span>,:],n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>, win_length = <span class="literal">None</span>, window=<span class="string">&#x27;hann&#x27;</span>,center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_mic1 = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_mic1),ref=np.<span class="built_in">max</span>)</span><br><span class="line">plt.subplot(<span class="number">325</span>)</span><br><span class="line">img1 = librosa.display.specshow(stft_mic1,sr=<span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of mic 1&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">326</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(room.mic_array.signals[<span class="number">1</span>,:]))/room.fs, room.mic_array.signals[<span class="number">1</span>,:])</span><br><span class="line">plt.title(<span class="string">&#x27;Microphone 1 signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>可以分别看到到达mic0和mic1的房间的RIR以及分别此时mic0和mic1采集到的音频数据信号。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301152851290.png" alt="image-20230301152851290" style="zoom:33%;" />

<p>再分别画出干净信号，mic0和mic1对应的spectrogram如下图所示：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301163646304.png" alt="image-20230301163646304" style="zoom: 33%;" />

<p>可以从spectrogram中看到明显加了混响后的信号多了一些能量拖尾，并且如果收听增加了混响后的语音，可以很明显感觉到混响的增加。</p>
<h4 id="方法二：Image-Source-Method-算法"><a href="#方法二：Image-Source-Method-算法" class="headerlink" title="方法二：Image Source Method 算法"></a>方法二：Image Source Method 算法</h4><p>镜像源法的算法原理为：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301164520887.png" alt="image-20230301164520887" style="zoom:50%;" />

<p>我们考虑每个反射面都是一个镜像，也就是说，如果我们在开放空间内有一面平整墙面，那么此时一个声源就可以等价视作为两个声源。如果开放空间中有两面垂直的平整墙面，那么一个声源就可以等效为4个，三面就是八个….进而拓展到封闭的三维空间中，也就是六个面。关于这一块的详细代码可以看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/LXP-Never/p/13404523.html">语音数据增强及python实现 - 凌逆战 - 博客园 (cnblogs.com)</a> 以及 <a target="_blank" rel="noopener" href="https://github.com/audiolabs/rir-generator">audiolabs&#x2F;rir-generator (github.com)</a></p>
<h3 id="四、波形位移-（time-shifting-（时域）"><a href="#四、波形位移-（time-shifting-（时域）" class="headerlink" title="四、波形位移 （time shifting) （时域）"></a>四、波形位移 （time shifting) （时域）</h3><p>语音波形在时域的位移我们可以用$numpy.roll$ 函数将整个数据向右移动shift的距离</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.roll(a,shift,axis = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>这里的参数：</p>
<ul>
<li>$a:$数组</li>
<li>$shift$: 滚动的长度</li>
<li>$axis$: 滚动的维度， 0 为垂直滚动，1为水平滚动,如果设置为None,会将数组扁平化，进行滚动操作后再恢复原始形状</li>
</ul>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.roll(x, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">time_shift</span>(<span class="params">x, shift</span>):</span><br><span class="line">    <span class="comment"># shift：移动的长度</span></span><br><span class="line">    <span class="keyword">return</span> np.roll(x, <span class="built_in">int</span>(shift))</span><br><span class="line"></span><br><span class="line">Augmentation = time_shift(wav_data, shift=fs//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301172438796.png" alt="image-20230301172438796" style="zoom: 33%;" />

<p>此时我们向右移动了$fs&#x2F;2 &#x3D; 8000$个采样点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to shift the signal</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_shift</span>(<span class="params">x,shift</span>):</span><br><span class="line">    <span class="comment"># shift: The length of shifting</span></span><br><span class="line">    <span class="keyword">return</span> np.roll(x, <span class="built_in">int</span>(shift))</span><br><span class="line"></span><br><span class="line">signal,_ = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line">spec_clean = librosa.stft(signal,n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>,win_length = <span class="literal">None</span>, window =<span class="string">&#x27;hann&#x27;</span>, center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_clean = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_clean),ref = np.<span class="built_in">max</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">librosa.display.specshow(stft_clean,sr = <span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of clean signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(signal))/<span class="number">16000</span>,signal)</span><br><span class="line">plt.title(<span class="string">&#x27;clean signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time[s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the shifted signal</span></span><br><span class="line">shifted_signal = time_shift(signal,<span class="number">16000</span>/<span class="number">2</span>)</span><br><span class="line">spec_shifted = librosa.stft(shifted_signal,n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>,win_length = <span class="literal">None</span>, window =<span class="string">&#x27;hann&#x27;</span>, center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_shifted = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_shifted),ref = np.<span class="built_in">max</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">librosa.display.specshow(stft_shifted,sr = <span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of shifted signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(shifted_signal))/<span class="number">16000</span>,shifted_signal)</span><br><span class="line">plt.title(<span class="string">&#x27;shifted signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time[s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>





<h3 id="五、音高（音调）增强-（Pitch-shifting-（频域）"><a href="#五、音高（音调）增强-（Pitch-shifting-（频域）" class="headerlink" title="五、音高（音调）增强  （Pitch shifting) （频域）"></a>五、音高（音调）增强  （Pitch shifting) （频域）</h3><p>在这里我们在频率轴上缩放频谱图，从而改变音高，音高修正只会改变音高但是不会影响音速，一般在将步数取在-5和5之间。下图为上移大三度。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230301174725999.png" alt="image-20230301174725999" style="zoom: 50%;" />

<p>代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This script is used to shift the pitch</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pitch_shifting</span>(<span class="params">x,sr,n_steps,bins_peroctave=<span class="number">12</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param x:   input signal</span></span><br><span class="line"><span class="string">    :param sr:   sample rate</span></span><br><span class="line"><span class="string">    :param n_steps:  how many steps should it move</span></span><br><span class="line"><span class="string">    :param bins_peroctave:   how many steps per octave</span></span><br><span class="line"><span class="string">    :return: the result of pitch shifting</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    enhancement = librosa.effects.pitch_shift(x,sr,n_steps,bins_per_octave = bins_peroctave)</span><br><span class="line">    <span class="keyword">return</span> enhancement</span><br><span class="line"></span><br><span class="line">signal,_ = librosa.load(<span class="string">&#x27;speech@24kHz.wav&#x27;</span>)</span><br><span class="line">spec_clean = librosa.stft(signal,n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>,win_length = <span class="literal">None</span>, window =<span class="string">&#x27;hann&#x27;</span>, center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_clean = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_clean),ref = np.<span class="built_in">max</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">librosa.display.specshow(stft_clean,sr = <span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of clean signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(signal))/<span class="number">16000</span>,signal)</span><br><span class="line">plt.title(<span class="string">&#x27;clean signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time[s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the shifted signal</span></span><br><span class="line">shifted_signal = pitch_shifting(signal,<span class="number">16000</span>,n_steps = <span class="number">4</span>, bins_peroctave=<span class="number">12</span>)   <span class="comment"># Move up three degrees</span></span><br><span class="line"></span><br><span class="line">spec_shifted = librosa.stft(shifted_signal,n_fft = <span class="number">512</span>,hop_length = <span class="literal">None</span>,win_length = <span class="literal">None</span>, window =<span class="string">&#x27;hann&#x27;</span>, center = <span class="literal">True</span>, pad_mode = <span class="string">&#x27;reflect&#x27;</span>)</span><br><span class="line">stft_shifted = librosa.amplitude_to_db(np.<span class="built_in">abs</span>(spec_shifted),ref = np.<span class="built_in">max</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">librosa.display.specshow(stft_shifted,sr = <span class="number">16000</span>,x_axis = <span class="string">&#x27;time&#x27;</span>,y_axis = <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram of shifted signal&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(np.arange(<span class="built_in">len</span>(shifted_signal))/<span class="number">16000</span>,shifted_signal)</span><br><span class="line">plt.title(<span class="string">&#x27;shifted signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time[s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>



<h3 id="六、谱减算法"><a href="#六、谱减算法" class="headerlink" title="六、谱减算法"></a>六、谱减算法</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>其原理基于：假设噪声为加性噪声，通过从带噪语音谱中减去对噪声谱的估计，可以得到纯净的信号谱，而如何得到噪声谱呢，采取的是在不存在目标信号的期间，对噪声谱进行估计和更新（噪声是平稳的，或者噪声频谱在每次更新之间不会有太大的变化）</p>
<p>优点：计算直接，简单，只需要一次FFT和一次IFFT即可</p>
<p>缺点：其缺点在于，其是考虑噪声为加性噪声，并且是直接求减，那么需要注意在求减阶段造成的语音失真，如果减去太多，那么语音信息可能丢失，如果减去太少，会有一些干扰噪声残留。</p>
<p>我们假设$y(n)$ 为带噪语音输入信号，其由纯净语音信号$x(n)$ 和加性噪声$d(n)$ 组成，也就是$y(n) &#x3D; x(n) + d(n)$,  我们对上式两边同时做离散时间傅里叶变换：$Y(w) &#x3D; X(w) + D(w)$。</p>
<p>用极坐标的形式带表示频域的带噪语音信号：$Y(w) &#x3D; |Y(w)| e^{j\phi_y(w)}$</p>
<p>这里的$|Y(w)|$ 为幅度谱，$\phi_y(w)$ 为带噪信号的相位谱，同样，噪声谱也可以通过其幅度和相位谱来表示为$D(w) &#x3D; |D(w)|e^{j\phi_d(w)}$，我们可以通过无语音活动时（语音停顿的间隙）的平均幅度谱的估计来代替噪声的幅度谱$|D(w)|$ ，噪声的相位$\phi_d(w)$也可以由带噪语音的相位$\phi_y(w)$来代替（因为相位不会对语音可懂度造成影响），其只可能在一定程度上影响语音质量。</p>
<p>那么，综上所述，我们可以得到纯净语音信号谱的一个估计：</p>
<p>​																	$\hat{X}(w) &#x3D; [|Y(w)| - |\hat{D}(w)|]e^{j\phi_y(w)}$</p>
<p>而在我们增强信号的幅度谱时，可能$|\hat{X}(w)| &#x3D; [|Y(w)| - |\hat{D}(w)|]$ 为负值（比如错误估计噪声谱），此时考虑加入半波整流，将为负的谱分量置为零。</p>
<p>而我们不光在幅度谱可以对其处理，也可以考虑扩展到功率谱对其进行处理，将频域中的带噪语音信号与其频域共轭相乘，有：</p>
<p>$$|Y(w)|^2 &#x3D; |X(w)|^2 + |D(w)|^2 + X(w) \cdot D^*(w) + X^*(w)D(w) &#x3D; |X(w)|^2 + |D(w)|^2 + 2Re(X(w)D^*(w))$$</p>
<p>其中，我们不能直接得到$|D(w)|^2 ,X(w)\cdot D^*(w), X^*(w)\cdot D(w)$  这三项，考虑使用期望$E[|D(w)|^2]$, $E[|X(w)\cdot D^*(w)]$ 以及 </p>
<p>$E[|X(w)^* \cdot D(w)]$  来近似， 其中第一项期望我们可以通过估计无语音段来得到，而如果我们假定噪声信号具有零均值且与干净语音信号$x(n)$ 不相关的性质，那么后面两项期望可以简化为零。</p>
<p>那么纯净语音的功率谱估计可以表示为：</p>
<p>​																						$|\hat{X}(w)|^2 &#x3D; |Y(w)|^2 - |\hat{D}(w)|^2$</p>
<p>上式也可以表达为一个乘积形式 ：</p>
<p>$|\hat{X}(w)|^2 &#x3D; H^2(w)|Y(w)|^2$, 其中$H(w) &#x3D; \sqrt{1-\frac{|\hat{D}(w)|^2}{Y(w)^2}}$</p>
<p>这里的$H(w)$ 被称作为增益函数，其取值在0，1之间。</p>
<p>而这里因为我们考虑噪声为加性噪声，那么在某个频率$w_k$ 处的带噪信号谱$Y(w_k)$ 是由在当前频率处两个信号的复数谱相加而成，也就可以在复平面上表示出来，通过这种几何观点，我们有：<strong>信噪比越大，带噪相位$\theta_y$ 与纯净相位$\theta_X$ 之差越小，也就是在频率处具有较大信噪比时，采用带噪信号谱的相位来代替纯净信号谱相位是可行的，只要相位差不被听觉系统所感知到，就采用带噪信号的相位，相位差取值范围为$[\pi&#x2F;8, \pi&#x2F;4]$</strong> ，而相位失配会让人感觉到“音质粗糙”。</p>
<p>在Louiz语音增强书中有从几何分析来推导 <em>估计信号和噪声之间的相位差</em>。 并且能够得到一定的结论：<strong>在信噪比足够高，即频谱信噪比不小于8dB时，相位差不会被感知到，也就是使用带噪信号相位代替纯净信号相位是安全的。</strong></p>
<h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><p>第一个就是上一节末尾提到的，使用带噪信号相位，可能会带来比较粗糙的合成语音质量。</p>
<p>在我们之前提到过，这里采用的噪声是加性噪声，无论是采用带噪语音的幅度谱还是功率谱与估计出的噪声谱相减时，可能会有负值出现，这并不是我们想要的结果，声音的幅度也不可能为负数，所以这里说明我们对噪声的预测出现了过估计行为，在之前我们采取的方法是使用半波整流，将负值设为0，以保证发非负的幅度谱。但是这种采用这种方法并不是万无一失的，这会导致信号帧频谱的随机位置上出现小的，独立的峰值。转换到时域后，这些峰值听起来就像帧与帧之间的颤音，这被称为<strong>音乐噪声</strong> ,音乐噪声在语音的清音段更为明显，因为此时噪声的功率与语音功率接近，所以此时音乐噪声比原本干扰噪声更为恼人。而通常，导致音乐噪声的主要原因有：</p>
<ul>
<li>对谱减中的负数部分进行的非线性处理</li>
<li>对噪声谱的估计不准，因为我们没有办法得到噪声谱，便退而求其次使用噪声的平均估计来估计噪声的幅值，而估计的平均值和实际实时噪声分量之间可能有较大的偏差</li>
<li>增益函数&#x2F;抑制函数 有较大的可变性</li>
</ul>
<h4 id="弥补方法"><a href="#弥补方法" class="headerlink" title="弥补方法"></a>弥补方法</h4><h5 id="一、过减法-oversubtraction"><a href="#一、过减法-oversubtraction" class="headerlink" title="一、过减法(oversubtraction)"></a>一、过减法(oversubtraction)</h5><p>首先考虑的减小音乐噪声的方法是对谱减的负值设置一个下限，而不是将其全部设为0，这个下限根据相邻帧的最小谱值确定。也就是说现在有表达式：</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230326172112035.png" alt="image-20230326172112035" style="zoom:50%;" />

<p>其中$\alpha$ 为过减因子($\alpha \geq 1$) ，$\beta(0\leq \beta \leq1)$ 为谱下限参数，提出这两个参数的主要动机在于：当从带噪语音谱中减去噪声谱估计的时候，频谱中会残留一部分隆起的部分或者谱峰，有些谱峰是宽带，而有些谱峰是窄带（如同一个脉冲），通过过减因子，我们可以减小宽带谱峰的幅度，并且有时可以完全将其消除，而谱峰周围有可能存在一些谱谷，所以引入谱下限来“填充”谱谷，并可能掩盖那些具有相近幅度的谱峰。 如果$\beta$ 太大，那么可能听到残留噪声信号但是感觉不到音乐噪声，如果$\beta$太小，那么可能会带来音乐噪声，但是原噪声会被极大程度的抑制。下图就是固定$\alpha$ 值而取不同$\beta$值的频谱效果。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230326172918513.png" alt="image-20230326172918513" style="zoom: 50%;" />

<p>而参数$\alpha$ 影响语音谱在谱减过程中的失真程度，如果$\alpha$ 过大，处理后的信号会严重失真以至于影响语音可懂度。所以在一些实验结果表明：要尽可能好地抑制噪声同时又能达到最小的音乐噪声，在高信噪比数据帧（即有语音存在时），$\alpha$ 应该取小值，而对低信噪比（语音的低能量段或是没有语音时）$\alpha$ 应取大值。而Berouti等人做了大量实验来确定$alpha$ 和$beta$ 的最优值，我们考虑直接采用，关于详细的$\alpha $和$\beta$的取值可以从语音增强书中看到，这里就不在提及。</p>
<h2 id="7、信号的时频域特征"><a href="#7、信号的时频域特征" class="headerlink" title="7、信号的时频域特征"></a>7、信号的时频域特征</h2><p>我最近学习了如何采用深度学习的方法来做音频信号处理的分析，如声源定位等，而第一步便是找到合适的输入神经网络的输入特征，</p>
<h3 id="一、信号的时域特征"><a href="#一、信号的时域特征" class="headerlink" title="一、信号的时域特征"></a>一、信号的时域特征</h3><p>信号的时域特征主要包含幅值博阿萝、过零率等</p>
<h4 id="①幅值包络：Amplitude-Envelope"><a href="#①幅值包络：Amplitude-Envelope" class="headerlink" title="①幅值包络：Amplitude Envelope"></a>①幅值包络：Amplitude Envelope</h4><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408183544284.png" alt="image-20230408183544284" style="zoom:50%;" />

<p>应用：振幅包络可以给出响度的大致信息，对于突变信号敏感，常用于音频检测，音频分类等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment">### extract the amplitude envelope of signal</span></span><br><span class="line"><span class="comment"># 0. import the necessary packages</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 振幅包络可以给出响度的大致信息，对于突变信号敏感</span></span><br><span class="line"><span class="comment"># 常用于音频检测，音频分类等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 1. load the audio file</span></span><br><span class="line">wave_path = <span class="string">r&quot;/root/autodl-tmp/base_env/audio_signal_processing/speech@24kHz.wav&quot;</span></span><br><span class="line">waveform, sample_rate = librosa.load(wave_path, sr=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 2. define a function AE that can extract the maximum amplitude of each frame and combine them as the envelope of signal</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Calc_Amplitude_Envelope</span>(<span class="params">waveform,frame_length,hop_length</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(waveform ) % hop_length !=<span class="number">0</span>:</span><br><span class="line">        frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform)-frame_length)/hop_length)+<span class="number">1</span></span><br><span class="line">        pad_num = frame_num*hop_length+frame_length - <span class="built_in">len</span>(waveform)</span><br><span class="line">        waveform = np.pad(waveform,(<span class="number">0</span>,pad_num),mode =<span class="string">&quot;wrap&quot;</span>)</span><br><span class="line">    frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform)-frame_length)/hop_length)+<span class="number">1</span></span><br><span class="line">    waveform_ae = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(frame_num):</span><br><span class="line">        current_frame = waveform[t*(frame_length - hop_length):t*(frame_length - hop_length)+frame_length]</span><br><span class="line">        current_ae = <span class="built_in">max</span>(current_frame)</span><br><span class="line">        waveform_ae.append(current_ae)</span><br><span class="line">    <span class="keyword">return</span> np.array(waveform_ae)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 3. set the parameters</span></span><br><span class="line">frame_size  = <span class="number">1024</span></span><br><span class="line">hop_size = <span class="built_in">int</span>(frame_size*<span class="number">0.5</span>)</span><br><span class="line">waveform_AE = Calc_Amplitude_Envelope(waveform = waveform,frame_length =frame_size,hop_length=hop_size)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 4. plot the wave  form and its amplitude envelope</span></span><br><span class="line">frame_scale = np.arange(<span class="number">0</span>,<span class="built_in">len</span>(waveform_AE))</span><br><span class="line">time_scale = librosa.frames_to_time(frame_scale, sr=sample_rate, hop_length=hop_size)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">librosa.display.waveshow(waveform, sr=sample_rate)</span><br><span class="line">plt.title(<span class="string">&#x27;Amplitude_envelope&#x27;</span>)</span><br><span class="line">plt.plot(time_scale,waveform_AE,color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上算法提取到的信号幅值包络，如下，主要操作就是先定义帧长，帧移，然后计算出帧的数量，再给原信号补零至恰好能被帧长整除，得到整数个帧的数量，最后遍历每一帧，计算当前帧中的幅值最大值，最后将幅值最大值加到一个list中，最后将所有帧的幅值最大值连起来，就得到了信号的幅值包络。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408183808051.png" alt="image-20230408183808051" style="zoom: 33%;" />





<h4 id="②均方根能量：Root-mean-square-energy"><a href="#②均方根能量：Root-mean-square-energy" class="headerlink" title="②均方根能量：Root mean square energy"></a>②均方根能量：Root mean square energy</h4><p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408184838813.png" alt="image-20230408184838813"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment">### This script is used to calculate the root mean square energy of the siganl</span></span><br><span class="line"><span class="comment">## the main idea is to calculate the rms energy of each frame and then average the rms energy of all frames</span></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 0. import the packages</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 1. load the audio file</span></span><br><span class="line">audio_path = <span class="string">&#x27;/root/autodl-tmp/base_env/audio_signal_processing/speech@24kHz.wav&#x27;</span></span><br><span class="line">waveform,sample_rate = librosa.load(audio_path,sr=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Define function RMS, which is used to calculate the RMS energy of each frame</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Calc_RMS</span>(<span class="params">waveform,frame_length,hop_length</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(waveform) % hop_length !=<span class="number">0</span>:</span><br><span class="line">        frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform) - frame_length)/hop_length) + <span class="number">1</span></span><br><span class="line">        pad_num = frame_num * hop_length + frame_length - <span class="built_in">len</span>(waveform)</span><br><span class="line">        waveform = np.pad(waveform,pad_width=(<span class="number">0</span>,pad_num),mode=<span class="string">&#x27;wrap&#x27;</span>)</span><br><span class="line">    frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform) - frame_length)/hop_length) + <span class="number">1</span></span><br><span class="line">    waveform_rms = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(frame_num):</span><br><span class="line">        current_frame = waveform[t*(frame_length - hop_length):t*(frame_length-hop_length)+frame_length]</span><br><span class="line">        current_rms = np.sqrt(np.<span class="built_in">sum</span>(current_frame ** <span class="number">2</span>) / frame_length)</span><br><span class="line">        waveform_rms.append(current_rms)</span><br><span class="line">    <span class="keyword">return</span> np.array(waveform_rms)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 4. Initial parameters and call the function</span></span><br><span class="line">frame_size = <span class="number">1024</span></span><br><span class="line">hop_size = <span class="built_in">int</span>(frame_size * <span class="number">0.5</span>)</span><br><span class="line">waveform_RMS = Calc_RMS(waveform,frame_size,hop_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 5. plot the result</span></span><br><span class="line">frame_scale = np.arange(<span class="number">0</span>,<span class="built_in">len</span>(waveform_RMS),step=<span class="number">1</span>)</span><br><span class="line">time_scale = librosa.frames_to_time(frame_scale)</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">plt.plot(time_scale,waveform_RMS,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">librosa.display.waveshow(waveform)</span><br><span class="line">plt.title(<span class="string">&#x27;Root-Mean-Square Energy&#x27;</span>,fontsize = <span class="number">20</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 6. Use the librosa.feature.rms to plot the rms of signal</span></span><br><span class="line">waveform_RMS_librosa = librosa.feature.rms(y=waveform,frame_length=frame_size,hop_length=hop_size).T[<span class="number">1</span>:,<span class="number">0</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">plt.plot(time_scale,waveform_RMS_librosa,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">librosa.display.waveshow(waveform)</span><br><span class="line">plt.title(<span class="string">&#x27;Root-Mean-Square Energy_librosa&#x27;</span>,fontsize = <span class="number">20</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 7. Compare two methods and calculate the bias</span></span><br><span class="line">bias = waveform_RMS_librosa - waveform_RMS</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the bias is <span class="subst">&#123;bias&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># As we can see, the bias between our method and librosa is so low (around e-10) and we can assume that our method makes sense</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到我们可以通过自己去分割信号为帧（分割手法和之前计算幅值包络相同），然后遍历所有帧去寻找每一帧的RMSE（这一帧当中每个点的幅值取平方后再取均值后开根号）</p>
<p>同样我们也可以调用$librosa.features$ 库中的$rms$ 方法来实现寻找每一帧的RMSE。</p>
<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408185039247.png" alt="image-20230408185039247" style="zoom: 33%;" />

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408185053609.png" alt="image-20230408185053609" style="zoom: 33%;" />



<h4 id="③过零率：Zero-crossing-rate"><a href="#③过零率：Zero-crossing-rate" class="headerlink" title="③过零率：Zero crossing rate"></a>③过零率：Zero crossing rate</h4><p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408190529801.png" alt="image-20230408190529801"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment">### This script is used to Presents the ratio of signal sign changes, i.e., the number of times the speech signal changes from positive to negative or from negative to positive in each frame</span></span><br><span class="line"><span class="comment">## It is calculating the zero crossing number at t frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 0. import the package</span></span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 1. load the signal</span></span><br><span class="line">wave_path = <span class="string">r&#x27;/root/autodl-tmp/base_env/audio_signal_processing/speech@24kHz.wav&#x27;</span></span><br><span class="line">waveform,sample_rate = librosa.load(wave_path,sr=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 2. Define function to calculate zero-crossing rate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Calc_ZCR</span>(<span class="params">waveform,frame_length,hop_length</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(waveform) % hop_length !=<span class="number">0</span>:</span><br><span class="line">        frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform)-frame_length)/hop_length)+<span class="number">1</span></span><br><span class="line">        pad_num = frame_num * hop_length + frame_length - <span class="built_in">len</span>(waveform)</span><br><span class="line">        waveform = np.pad(waveform,(<span class="number">0</span>,pad_num),mode=<span class="string">&#x27;wrap&#x27;</span>)</span><br><span class="line">    frame_num = <span class="built_in">int</span>((<span class="built_in">len</span>(waveform)-frame_length)/hop_length)+<span class="number">1</span></span><br><span class="line">    waveform_zcr = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(frame_num):</span><br><span class="line">        current_frame = waveform[(frame_length - hop_length) * t : (frame_length - hop_length)*t + frame_length]</span><br><span class="line">        prev = np.sign(current_frame[<span class="number">0</span>:frame_length-<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">next</span> = np.sign(current_frame[<span class="number">1</span>:frame_length])</span><br><span class="line">        current_zcr = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(prev-<span class="built_in">next</span>))/<span class="number">2</span>/frame_length</span><br><span class="line">        waveform_zcr.append(current_zcr)</span><br><span class="line">    <span class="keyword">return</span> np.array(waveform_zcr)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 3. Initial the parameters</span></span><br><span class="line">frame_size = <span class="number">1024</span></span><br><span class="line">hop_size = <span class="built_in">int</span>(frame_size * <span class="number">0.5</span>)</span><br><span class="line">waveform_ZCR = Calc_ZCR(waveform, frame_size,hop_size)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. plot the figure</span></span><br><span class="line">frame_scale = np.arange(<span class="number">0</span>,<span class="built_in">len</span>(waveform_ZCR),step=<span class="number">1</span>)</span><br><span class="line">time_scale = librosa.frames_to_time(frame_scale)</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">librosa.display.waveshow(waveform)</span><br><span class="line">plt.plot(time_scale,waveform_ZCR,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Zero Cross Rate&#x27;</span>,fontsize = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 5. use librosa.feature to calculate zero-cross-rate</span></span><br><span class="line">waveform_ZCR_librosa = librosa.feature.zero_crossing_rate(y=waveform,frame_length=frame_size,hop_length = hop_size).T[<span class="number">1</span>:,<span class="number">0</span>]</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">librosa.display.waveshow(waveform)</span><br><span class="line">plt.plot(time_scale,waveform_ZCR_librosa,color=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Zero Cross Rate_librosa&#x27;</span>,fontsize = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># Calculate the difference</span></span><br><span class="line">bias = waveform_ZCR_librosa - waveform_ZCR</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;the bias is <span class="subst">&#123;bias&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里主要是先将信号分帧，然后遍历每一帧中，然后定义两个点$prev$ 和$next$，一个取值范围为【当前帧的初始值到帧长-1】，另一个的取值范围为【当前帧的初始长+1 到 帧长】，然后分别对这两个值取sgn()函数，最后用前一个点与后一个点相减再取绝对值，再求和并取均值（除以2）</p>
<p>同理我们也可以考虑使用$librosa.feature.zeros$_crossing_rate   来提取当前信号的过零率。 </p>
 <img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408190642840.png" alt="image-20230408190642840" style="zoom: 33%;" />		

<img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408190650923.png" alt="image-20230408190650923" style="zoom:33%;" />



<h3 id="二、信号的频域特征"><a href="#二、信号的频域特征" class="headerlink" title="二、信号的频域特征"></a>二、信号的频域特征</h3><h4 id="①谱质心和子带带宽-Spectral-centroid-and-Bandwidth"><a href="#①谱质心和子带带宽-Spectral-centroid-and-Bandwidth" class="headerlink" title="①谱质心和子带带宽(Spectral centroid and Bandwidth)"></a>①谱质心和子带带宽(Spectral centroid and Bandwidth)</h4><p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408192425213.png" alt="image-20230408192425213"></p>
<p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408192437498.png" alt="image-20230408192437498"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment">### This script is used to calculate the centroid of the spectrogram in frequency domain</span></span><br><span class="line"><span class="comment"># 谱质心是频率成分的重心，是频谱中在一定频率范围内通过能量加权平均的频率</span></span><br><span class="line"><span class="comment"># 每一帧的幅值 * 对应点的频率的和/每帧的幅值之和</span></span><br><span class="line"><span class="comment"># 其主要描述了声音的明亮度，具有低沉品质的声音倾向于有较多低频内容，谱质心较低，而具有明亮，欢快的声音更多集中于高频，谱质心更高，常用于对</span></span><br><span class="line"><span class="comment"># 乐器音色的分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子带带宽是指在spectral centroid的频谱范围，计算每一点到谱质心的加权平均值。</span></span><br><span class="line"><span class="comment"># 用于描述主观听觉的感受，类似于频谱的变化速度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 0. Import packages</span></span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 1. load signal</span></span><br><span class="line">jazz_path = <span class="string">r&#x27;/root/autodl-tmp/base_env/audio_signal_processing/audio_data/49658__sub-d__more-jazz-guitar.wav&#x27;</span></span><br><span class="line">jazz,sr = librosa.load(jazz_path,sr=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">rock_path = <span class="string">r&#x27;/root/autodl-tmp/base_env/audio_signal_processing/audio_data/75314__oymaldonado__bluesy-rock-guitar2.wav&#x27;</span></span><br><span class="line">rock,sr = librosa.load(rock_path,sr=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">orchestra_path = <span class="string">r&#x27;/root/autodl-tmp/base_env/audio_signal_processing/audio_data/528773__mrthenoronha__classical-waltz-loop.wav&#x27;</span></span><br><span class="line">orchestra,sr =librosa.load(orchestra_path,sr= <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 2. Get the spectral centroid</span></span><br><span class="line">sc_jazz = librosa.feature.spectral_centroid(y=jazz,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line">sc_rock = librosa.feature.spectral_centroid(y=rock,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line">sc_orchestra = librosa.feature.spectral_centroid(y=orchestra,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line"><span class="comment"># 3. plot the centroid of the signal</span></span><br><span class="line">plt.figure(figsize=(<span class="number">60</span>,<span class="number">30</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sc_jazz)),sc_jazz,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Jazz&#x27;</span>,fontsize=<span class="number">25</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sc_rock)),sc_rock,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Rock&#x27;</span>,fontsize=<span class="number">25</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sc_orchestra)),sc_orchestra,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Orchestra&#x27;</span>,fontsize=<span class="number">25</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们直接调用$librosa.feature.spectral_centorid$ 来计算对应信号的频谱质心，其表示的核心含义就是频率成分的重心。可以很明显的看到明显高频成分比较多的管弦乐有着更高的频谱质心，同样其对应有着人感知更为明亮欢快的声音，而对于Jazz和Rock等明显低频成分较多的音乐，其的频谱质心相对较低，也就是对应了有着更阴暗、低沉的声音。</p>
 <img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408192613900.png" alt="image-20230408192613900" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. get the spectral bandwidth of signal</span></span><br><span class="line">sw_jazz = librosa.feature.spectral_bandwidth(y=jazz,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line">sw_rock = librosa.feature.spectral_bandwidth(y=rock,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line">sw_orchestra = librosa.feature.spectral_bandwidth(y=orchestra,n_fft=<span class="number">1024</span>).reshape(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#%%</span></span><br><span class="line">plt.figure(figsize=(<span class="number">60</span>,<span class="number">30</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sw_jazz)),sw_jazz,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Jazz&#x27;</span>,fontsize=<span class="number">25</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sw_rock)),sw_rock,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Rock&#x27;</span>,fontsize=<span class="number">25</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">0</span>,<span class="built_in">len</span>(sw_orchestra)),sw_orchestra,linewidth=<span class="number">3</span>,color=<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Orchestra&#x27;</span>,fontsize=<span class="number">25</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们调用$librosa.feature.spectral_bandwidth$ 来计算对应信号的子带带宽，其核心含义为能够判断频谱的变化速度，如果音频的能量谱密度下降快，那么对应的BW也下降快。</p>
<p><img src="/images/%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/image-20230408194318886.png" alt="image-20230408194318886" style="zoom: 33%;" />guoguo</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Gavin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/25/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">http://example.com/2023/08/25/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%A8python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Gavin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/">开源代码</a></div><div class="post_share"><div class="social-share" data-image="https://i.ibb.co/Tw3pLRH/68747470733a2f2f692e68697a6c69726573696d2e636f6d2f564d7935596a2e706e67.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/25/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9ALocalization%20of%20Multiple%20Speakers%20under%20High%20Reverberation%20using%20a%20Spherical%20Microphone%20Array%20and%20the%20Direct-Path%20Dominance%20Test/" title="文献阅读:Localization of Multiple Speakers under High Reverberation using a Spherical Microphone Array and the Direct-Path Dominance Test"><img class="cover" src="https://i.ibb.co/GQZT1sx/image-20230822154738866.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文献阅读:Localization of Multiple Speakers under High Reverberation using a Spherical Microphone Array and the Direct-Path Dominance Test</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/05/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9ADEEP%20GENERATIVE%20FIXED-FILTER%20ACTIVE%20NOISE%20CONTROL/" title="文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL"><img class="cover" src="https://i.ibb.co/LSLjfkw/image.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="title">文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL</div></div></a></div><div><a href="/2024/04/23/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AA%20Hybrid%20SFANC-FxNLMS%20Algorithm%20for%20Active%20Noise%20Control%20based%20on%20Deep%20Learning/" title="文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning"><img class="cover" src="https://i.ibb.co/5GmwJBS/image.png	" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-23</div><div class="title">文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning</div></div></a></div><div><a href="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFA-weighting/" title="知识总结：什么是A-weighting"><img class="cover" src="https://i.ibb.co/bLcJFgv/image.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">知识总结：什么是A-weighting</div></div></a></div><div><a href="/2023/08/27/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%8B%E7%BC%A9%E6%84%9F%E7%9F%A5%E7%AE%80%E4%BB%8B/" title="知识总结：压缩感知(compressive sensing)简介"><img class="cover" src="https://i.ibb.co/BPsTpHq/image.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-27</div><div class="title">知识总结：压缩感知(compressive sensing)简介</div></div></a></div><div><a href="/2024/01/13/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%90%83%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%E7%9A%84%E5%A3%B0%E6%BA%90DoA%E4%BC%B0%E8%AE%A1/" title="知识总结: 基于球麦克风阵列的声源DoA估计"><img class="cover" src="https://i.ibb.co/1dkyDjy/acoustic-camera-gfaitech-Sphere120-beamforming-microphone-array-3d-measurement-interior-right.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">知识总结: 基于球麦克风阵列的声源DoA估计</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.ibb.co/ch2RrDp/20230822001522.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gavin</div><div class="author-info__description">我的过去常常追赶着我</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/alexandergwm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/alexandergwm" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wenmiaogao@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">May you stay young forever, do the thing in your own zone.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8Python%E5%81%9A%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">用Python做信号处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Python-%E7%94%9F%E6%88%90%E6%AD%A3%E5%BC%A6%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.</span> <span class="toc-text">1、Python 生成正弦信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Python%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.</span> <span class="toc-text">2、Python读取与保存音频信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-DFT"><span class="toc-number">1.3.</span> <span class="toc-text">3、离散傅里叶变换(DFT)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Scipy-%E5%8C%85%E7%9A%84FFT"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、Scipy 包的FFT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E8%BF%87%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E6%B1%82DFT"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、通过矩阵运算求DFT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、傅里叶变换的基本性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">一、线性性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B3%E7%A7%BB%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">二、平移性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E7%A7%B0%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">三、对称性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8D%B7%E7%A7%AF%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">四、卷积性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%8D%B7%E7%A7%AF-%EF%BC%88Convolution%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4、卷积 （Convolution）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FFT%E5%8D%B7%E7%A7%AF%EF%BC%88%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">FFT卷积（快速傅里叶变换）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%B9%B2%E5%87%80%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%B7%B7%E5%93%8D-%EF%BC%88%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">在干净语音信号中增加混响 （傅里叶变换的应用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8FFT%E5%B0%86%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2%E5%88%B0%E9%A2%91%E5%9F%9F%E5%8E%BB%E9%99%A4%E8%83%BD%E9%87%8F%E8%BE%83%E4%BD%8E%E7%9A%84%E5%BA%95%E5%99%AA-%EF%BC%88%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">用FFT将信号转换到频域去除能量较低的底噪 （傅里叶变换的应用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E6%96%B9%E6%B3%95%EF%BC%88overlap-add%E5%92%8Coverlap-save"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">更快的卷积方法（overlap-add和overlap-save)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Overlap-add"><span class="toc-number">1.4.1.3.1.</span> <span class="toc-text">Overlap-add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Overlap-save"><span class="toc-number">1.4.1.3.2.</span> <span class="toc-text">Overlap-save</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-STFT"><span class="toc-number">1.5.</span> <span class="toc-text">5、短时傅里叶变换 STFT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">短时傅里叶变换是什么？我们为什么要用它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">窗函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2%E7%AA%97%EF%BC%9A"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">矩形窗：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hanning%E7%AA%97%EF%BC%88%E5%8D%87%E4%BD%99%E5%BC%A6%E7%AA%97%EF%BC%89"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Hanning窗（升余弦窗）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hamming-%E6%94%B9%E8%BF%9B%E5%8D%87%E4%BD%99%E5%BC%A6%E7%AA%97"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">Hamming: 改进升余弦窗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blackman%E7%AA%97%EF%BC%88%E4%BA%8C%E9%98%B6%E5%8D%87%E4%BD%99%E5%BC%A6%E7%AA%97%EF%BC%89"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">Blackman窗（二阶升余弦窗）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STFT%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.5.3.</span> <span class="toc-text">STFT的原理及实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mel%E9%A2%91%E8%B0%B1%E4%BB%A5%E5%8F%8AMel%E5%80%92%E8%B0%B1%E7%B3%BB%E6%95%B0%EF%BC%88MFCC%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">Mel频谱以及Mel倒谱系数（MFCC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1、预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E9%A2%84%E5%8A%A0%E9%87%8D"><span class="toc-number">1.5.4.1.1.</span> <span class="toc-text">① 预加重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E3%80%81%E5%88%86%E5%B8%A7"><span class="toc-number">1.5.4.1.2.</span> <span class="toc-text">②、分帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E3%80%81%E5%8A%A0%E7%AA%97-window"><span class="toc-number">1.5.4.1.3.</span> <span class="toc-text">③、加窗 (window)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81FFT"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2、FFT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8A%9F%E7%8E%87%E8%B0%B1"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">3、功率谱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Mel-%E5%88%BB%E5%BA%A6%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%BB%84"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">4、Mel 刻度滤波器组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Mel-%E9%A2%91%E7%8E%87%E5%80%92%E8%B0%B1%E7%B3%BB%E6%95%B0%EF%BC%88MFCC%EF%BC%89"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">5、Mel 频率倒谱系数（MFCC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.6.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.6.</span> <span class="toc-text">6、语音数据增强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AF%BC%E5%85%A5%E5%8E%9F%E5%A7%8B%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.1.</span> <span class="toc-text">一、导入原始语音数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A2%9E%E5%8A%A0%E5%99%AA%E5%A3%B0-Noise-addition-%EF%BC%88%E6%97%B6%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">二、增加噪声 (Noise addition)  （时域）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%AA%E5%A3%B0%E5%9B%A0%E5%AD%90"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">①、控制噪声因子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E3%80%81%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%99%AA%E6%AF%94"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">②、控制信噪比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B7%B7%E5%93%8D%E5%A2%9E%E5%BC%BA-Reverberation-addition-%EF%BC%88%E6%97%B6%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">三、混响增强 (Reverberation addition)  （时域）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9APyroomacoustic-%E5%BA%93%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E5%8A%A0%E6%B7%B7%E5%93%8D"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">方法一：Pyroomacoustic 库实现音频加混响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AImage-Source-Method-%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">方法二：Image Source Method 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%A2%E5%BD%A2%E4%BD%8D%E7%A7%BB-%EF%BC%88time-shifting-%EF%BC%88%E6%97%B6%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">四、波形位移 （time shifting) （时域）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9F%B3%E9%AB%98%EF%BC%88%E9%9F%B3%E8%B0%83%EF%BC%89%E5%A2%9E%E5%BC%BA-%EF%BC%88Pitch-shifting-%EF%BC%88%E9%A2%91%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">五、音高（音调）增强  （Pitch shifting) （频域）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%B0%B1%E5%87%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.6.</span> <span class="toc-text">六、谱减算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">不足之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A5%E8%A1%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">弥补方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%87%E5%87%8F%E6%B3%95-oversubtraction"><span class="toc-number">1.6.6.3.1.</span> <span class="toc-text">一、过减法(oversubtraction)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E9%A2%91%E5%9F%9F%E7%89%B9%E5%BE%81"><span class="toc-number">1.7.</span> <span class="toc-text">7、信号的时频域特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E5%9F%9F%E7%89%B9%E5%BE%81"><span class="toc-number">1.7.1.</span> <span class="toc-text">一、信号的时域特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%B9%85%E5%80%BC%E5%8C%85%E7%BB%9C%EF%BC%9AAmplitude-Envelope"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">①幅值包络：Amplitude Envelope</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%9D%87%E6%96%B9%E6%A0%B9%E8%83%BD%E9%87%8F%EF%BC%9ARoot-mean-square-energy"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">②均方根能量：Root mean square energy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%BF%87%E9%9B%B6%E7%8E%87%EF%BC%9AZero-crossing-rate"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">③过零率：Zero crossing rate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%A2%91%E5%9F%9F%E7%89%B9%E5%BE%81"><span class="toc-number">1.7.2.</span> <span class="toc-text">二、信号的频域特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%B0%B1%E8%B4%A8%E5%BF%83%E5%92%8C%E5%AD%90%E5%B8%A6%E5%B8%A6%E5%AE%BD-Spectral-centroid-and-Bandwidth"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">①谱质心和子带带宽(Spectral centroid and Bandwidth)</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/05/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9ADEEP%20GENERATIVE%20FIXED-FILTER%20ACTIVE%20NOISE%20CONTROL/" title="文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL"><img src="https://i.ibb.co/LSLjfkw/image.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL"/></a><div class="content"><a class="title" href="/2024/05/05/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9ADEEP%20GENERATIVE%20FIXED-FILTER%20ACTIVE%20NOISE%20CONTROL/" title="文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL">文献阅读: DEEP GENERATIVE FIXED-FILTER ACTIVE NOISE CONTROL</a><time datetime="2024-05-05T11:30:38.183Z" title="发表于 2024-05-05 19:30:38">2024-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AA%20Hybrid%20SFANC-FxNLMS%20Algorithm%20for%20Active%20Noise%20Control%20based%20on%20Deep%20Learning/" title="文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning"><img src="https://i.ibb.co/5GmwJBS/image.png	" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning"/></a><div class="content"><a class="title" href="/2024/04/23/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AA%20Hybrid%20SFANC-FxNLMS%20Algorithm%20for%20Active%20Noise%20Control%20based%20on%20Deep%20Learning/" title="文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning">文献阅读: A Hybrid SFANC-FxNLMS Algorithm for Active Noise Control based on Deep Learning</a><time datetime="2024-04-23T13:51:09.660Z" title="发表于 2024-04-23 21:51:09">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/27/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AMaximum%20Likelihood%20DOA%20Estimation%20of%20Multiple%20Wideband%20Sources%20in%20the%20Presence%20of%20Nonuniform%20Sensor%20Noise/" title="文献阅读: Maximum Likelihood DOA Estimation of Multiple Wideband Sources in the Presence of Nonuniform Sensor Noise"><img src="https://i.ibb.co/gtsst1D/image.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献阅读: Maximum Likelihood DOA Estimation of Multiple Wideband Sources in the Presence of Nonuniform Sensor Noise"/></a><div class="content"><a class="title" href="/2024/01/27/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9AMaximum%20Likelihood%20DOA%20Estimation%20of%20Multiple%20Wideband%20Sources%20in%20the%20Presence%20of%20Nonuniform%20Sensor%20Noise/" title="文献阅读: Maximum Likelihood DOA Estimation of Multiple Wideband Sources in the Presence of Nonuniform Sensor Noise">文献阅读: Maximum Likelihood DOA Estimation of Multiple Wideband Sources in the Presence of Nonuniform Sensor Noise</a><time datetime="2024-01-26T16:00:00.000Z" title="发表于 2024-01-27 00:00:00">2024-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/13/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%90%83%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%E7%9A%84%E5%A3%B0%E6%BA%90DoA%E4%BC%B0%E8%AE%A1/" title="知识总结: 基于球麦克风阵列的声源DoA估计"><img src="https://i.ibb.co/1dkyDjy/acoustic-camera-gfaitech-Sphere120-beamforming-microphone-array-3d-measurement-interior-right.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识总结: 基于球麦克风阵列的声源DoA估计"/></a><div class="content"><a class="title" href="/2024/01/13/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9F%BA%E4%BA%8E%E7%90%83%E9%BA%A6%E5%85%8B%E9%A3%8E%E9%98%B5%E5%88%97%E7%9A%84%E5%A3%B0%E6%BA%90DoA%E4%BC%B0%E8%AE%A1/" title="知识总结: 基于球麦克风阵列的声源DoA估计">知识总结: 基于球麦克风阵列的声源DoA估计</a><time datetime="2024-01-13T00:51:54.000Z" title="发表于 2024-01-13 08:51:54">2024-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/02/%E6%AF%94%E8%B5%9B%E7%9B%B8%E5%85%B3%EF%BC%9ADCASE%202019%20task3%20%20SELD%E5%A3%B0%E9%9F%B3%E4%BA%8B%E4%BB%B6%E5%AE%9A%E4%BD%8D%E6%A3%80%E6%B5%8B/" title="文献阅读: DCASE 2019 task3  SELD声音事件定位检测 data"><img src="https://i.ibb.co/b7XKwb2/image.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文献阅读: DCASE 2019 task3  SELD声音事件定位检测 data"/></a><div class="content"><a class="title" href="/2023/11/02/%E6%AF%94%E8%B5%9B%E7%9B%B8%E5%85%B3%EF%BC%9ADCASE%202019%20task3%20%20SELD%E5%A3%B0%E9%9F%B3%E4%BA%8B%E4%BB%B6%E5%AE%9A%E4%BD%8D%E6%A3%80%E6%B5%8B/" title="文献阅读: DCASE 2019 task3  SELD声音事件定位检测 data">文献阅读: DCASE 2019 task3  SELD声音事件定位检测 data</a><time datetime="2023-11-02T07:02:20.000Z" title="发表于 2023-11-02 15:02:20">2023-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Gavin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Have a nice day!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>